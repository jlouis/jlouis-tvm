@String{j-ibm-jrd = "IBM Journal of Research and Development"}

@TechReport{andersen:beregnelighed,
  author =       "Jesper Louis Andersen",
  title =        "Beregnelighed, bachelors thesis",
  institution =  "DIKU",
  year =         "2007",
  month =        jun,
  note =         "Contains a semantics for the language BrainF*ck",
  annote =       "My bachelors thesis",
}

@Article{crary:2003:toward,
  title={{Toward a foundational typed assembly language}},
  author={Crary, K.},
  journal={ACM SIGPLAN Notices},
  volume={38},
  number={1},
  pages={198--212},
  year={2003},
  publisher={ACM New York, NY, USA},
  annote="Still need to read this"
}

@Article{bennett:logical,
  author =       "C. H. Bennett",
  title =        "Logical Reversibility of Computation",
  journal =      j-ibm-jrd,
  volume =       "17",
  number =       "6",
  pages =        "525--532",
  month =        nov,
  year =         "1973",
  CODEN =        "IBMJAE",
  ISSN =         "0018-8646",
  MRclass =      "68A25",
  MRnumber =     "56 \#7325",
  bibsource =    "Compendex database",
  abstract =     "The usual general-purpose computing automation (e.g.,
                 a Turing machine) is logically irreversible --- its
                 function lacks a single-valued inverse. Here it is
                 shown that such machines may be made logically
                 reversible at every step, while retaining their
                 simplicity and their ability to do general
                 computations. This result is of great physical interest
                 because it makes plausible the existence of
                 thermodynamically reversible computers which could
                 perform useful computations at useful speed while
                 dissipating considerably less than kT of energy per
                 logical step. In the first stage of its computation the
                 logically reversible automaton parallels the
                 corresponding irreversible automaton, except that it
                 saves all intermediate results, thereby avoiding the
                 irreversible operation of erasure. The second stage
                 consists of printing out the desired output. The third
                 stage then reversibly disposes of all the undesired
                 intermediate results by retracing the steps of the
                 first stage in backward order (a process which is only
                 possible because the first stage has been carried out
                 reversibly), thereby restoring the machine (except for
                 the now-written output tape) to its original condition.
                 The final machine configuration thus contains the
                 desired output and a reconstructed copy of the input,
                 but no other undesired data. The foregoing results are
                 demonstrated explicitly using a type of three-tape
                 Turing machine. The biosynthesis of messenger RNA is
                 discussed as a physical example of reversible
                 computation.",
  acknowledgement = ack-nhfb,
  classcodes =   "C4220 (Automata theory)",
  classification = "723",
  corpsource =   "IBM, Yorktown Heights, NY, USA",
  journalabr =   "IBM J Res Dev",
  keywords =     "automata theory; computation; computer metatheory;
                 computing automaton; logical reversibility; Turing
                 machine",
  treatment =    "T Theoretical or Mathematical",
}

@Book{bertot.casteran:interactive,
  author =       "Yves Bertot and Pierre Cast\'eran",
  title =        "Interactive Theorem Proving and Program Development.
                 Coq'Art: The Calculus of Inductive Constructions",
  series =       "Texts in Theoretical Computer Science",
  year =         "2004",
  publisher =    "Springer Verlag",
}

@Misc{chlipala:certified,
  author =       "Adam Chlipala",
  title =        "Certified Programming with Dependent Types",
  year =         "2008",
  howpublished = "Available at \url{http://adam.chlipala.net/cpdt/}",
}

@Article{cooper:theorem,
  author =       "D. C. Cooper",
  title =        "Theorem Proving in Arithmetic without Multiplication",
  OPTjournal =   "",
  year =         "1972",
  OPTkey =       "",
  OPTvolume =    "",
  OPTnumber =    "",
  pages =        "91--100",
  OPTmonth =     "",
  OPTnote =      "",
  annote =       "I have not read this, but it looks like the right
                 paper to cite for presburger arithmetic",
}

@Proceedings{durand-lose.margenstern:machines,
  editor =       "J{\'e}r{\^o}me Olivier Durand-Lose and Maurice
                 Margenstern",
  title =        "Machines, Computations, and Universality, 5th
                 International Conference, {MCU} 2007, Orl{\'e}ans,
                 France, September 10-13, 2007, Proceedings",
  booktitle =    "MCU",
  publisher =    "Springer",
  series =       "Lecture Notes in Computer Science",
  volume =       "4664",
  year =         "2007",
  ISBN =         "978-3-540-74592-1",
  bibsource =    "DBLP, http://dblp.uni-trier.de",
}

@PhdThesis{fluet:monadic,
  author =       "Matthew Fluet",
  title =        "Monadic and Substructural Type Systems for
                 Region-Based Memory Management",
  school =       "Cornell University",
  year =         "2007",
  month =        jan,
  abs =          "../research/thesis/index.html#MonadicAndSubstructRegionsThesis07",
  pdfsingle =    "../research/thesis/fluet-thesis.double.pdf",
  pdfdouble =    "../research/thesis/fluet-thesis.single.pdf",
}

@Article{gluck.kawabe:method,
  author =       "Robert {Gl{\"{u}}ck,} and Masahiko {Kawabe,}",
  title =        "A Method for Automatic Program Inversion Based on
                 {LR}(0) Parsing",
  journal =      "Fundam. Inf.",
  volume =       "66",
  number =       "4",
  year =         "2005",
  ISSN =         "0169-2968",
  pages =        "367--395",
  publisher =    "IOS Press",
  address =      "Amsterdam, The Netherlands, The Netherlands",
}

@Article{hall.hammond.ea:type,
  abstract =     "This paper defines a set of type inference rules for
                 resolving overloading introduced by type classes.
                 Programs including type classes are transformed into
                 ones which may be typed by the Hindley-Milner inference
                 rules. In contrast to other work on type classes, the
                 rules presented here relate directly to user programs.
                 An innovative aspect of this work is the use of
                 second-order lambda calculus to record type information
                 in the program.",
  author =       "Cordelia V. Hall and Kevin Hammond and S. L. P. Simon
                 and Philip L. Wadler",
  citeulike-article-id = "4956",
  journal =      "ACM Transactions on Programming Languages and
                 Systems",
  keywords =     "class, haskell, type",
  month =        mar,
  number =       "2",
  pages =        "109--138",
  posted-at =    "2007-03-19 16:31:07",
  priority =     "2",
  publisher =    "ACM Press",
  title =        "Type Classes in Haskell",
  URL =          "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.5615",
  volume =       "18",
  year =         "1996",
}

@Misc{harper.crary:2005:how,
  author =       "Robert Harper and Karl Crary",
  title =        "How to Believe a Twelf Proof",
  year =         "2005",
  note =         {Published at \url{http://www.cs.cmu.edu/~rwh/papers.htm}}
}


@Misc{,
  OPTkey = 	 {},
  OPTauthor = 	 {},
  OPTtitle = 	 {},
  OPThowpublished = {},
  OPTmonth = 	 {},
  OPTyear = 	 {},
  OPTnote = 	 {},
  OPTannote = 	 {}
}

@Article{harper.honsell.ea:framework,
  author =       "Robert Harper and Furio Honsell and Gordon Plotkin",
  title =        "A framework for defining logics",
  journal =      "J. ACM",
  volume =       "40",
  number =       "1",
  year =         "1993",
  ISSN =         "0004-5411",
  pages =        "143--184",
  doi =          "http://doi.acm.org/10.1145/138027.138060",
  publisher =    "ACM Press",
}

@Article{harper.licata:mechanizing,
  author =       "Robert Harper and Daniel R. Licata",
  title =        "Mechanizing Metatheory in a Logical Framework",
  journal =      "Journal of Functional Programming",
  year =         "2007",
  note =         "(To appear.)",
}

@Book{jensen:klassisk,
  author =       "Christian U. Jensen",
  title =        "Klassisk Algebra",
  publisher =    "Universitetsbogladen",
  year =         "2003",
  OPTkey =       "",
  OPTvolume =    "",
  OPTnumber =    "",
  OPTseries =    "",
  OPTaddress =   "",
  OPTedition =   "",
  OPTmonth =     "",
  ISBN =         "",
  annote =       "This book was the one I used when I first learned
                 algebra. Written in Danish, it is simply *the* book for
                 more advanced studies in Algebra. It is not an easy
                 read, but it utterly smites the competition when it
                 comes to providing a precise accout. It also covers
                 Galois-tunnels",
}

@Article{landauer:irreversibility,
  abstract =     "It is argued that computing machines inevitably
                 involve devices which perform logical functions that do
                 not have a single-valued inverse. This logical
                 irreversibility is associated with physical
                 irreversibility and requires a minimal heat generation,
                 per machine cycle, typically of the order of kT for
                 each irreversible function. This dissipation serves the
                 purpose of standardizing signals and making them
                 independent of their exact logical history. Two simple,
                 but representative, models of bistable devices are
                 subjected to a more detailed analysis of switching
                 kinetics to yield the relationship between speed and
                 energy dissipation, and to estimate the effects of
                 errors induced by thermal fluctuations.",
  author =       "R. Landauer",
  citeulike-article-id = "2598931",
  journal =      "IBM Journal of Research and Development",
  keywords =     "information\_theory, maxwell\_daemon, thermodynamics",
  pages =        "183--191",
  posted-at =    "2008-03-26 15:23:10",
  priority =     "2",
  title =        "Irreversibility and heat generation in the computing
                 process",
  URL =          "http://domino.watson.ibm.com/tchjr/journalindex.nsf/0/8a9d4b4e96887b8385256bfa0067fba2?OpenDocument",
  volume =       "5",
  year =         "1961",
}

@Article{leroy.blazy:formal,
  author =       "Xavier Leroy and Sandrine Blazy",
  title =        "Formal verification of a {C}-like memory model and its
                 uses for verifying program transformations",
  journal =      "Journal of Automated Reasoning",
  year =         "2008",
  volume =       "41",
  number =       "1",
  pages =        "1--31",
  xtopic =       "compcert",
  URL =          "http://gallium.inria.fr/~xleroy/publi/memory-model-journal.pdf",
  urlpublisher = "http://dx.doi.org/10.1007/s10817-008-9099-0",
  abstract =     "This article presents the formal verification, using
                 the Coq proof assistant, of a memory model for
                 low-level imperative languages such as C and compiler
                 intermediate languages. Beyond giving semantics to
                 pointer-based programs, this model supports reasoning
                 over transformations of such programs. We show how the
                 properties of the memory model are used to prove
                 semantic preservation for three passes of the Compcert
                 verified compiler.",
}

@Article{leroy.grall:coinductive,
  author =       "Xavier Leroy and Hervé Grall",
  title =        "Coinductive big-step operational semantics",
  journal =      "Information and Computation",
  volume =       "207",
  number =       "2",
  pages =        "284--304",
  year =         "2009",
  urllocal =     "http://gallium.inria.fr/~xleroy/publi/coindsem-journal.pdf",
  urlpublisher = "http://dx.doi.org/10.1016/j.ic.2007.12.004",
  abstract =     "Using a call-by-value functional language as an
                 example, this article illustrates the use of
                 coinductive definitions and proofs in big-step
                 operational semantics, enabling it to describe
                 diverging evaluations in addition to terminating
                 evaluations. We formalize the connections between the
                 coinductive big-step semantics and the standard
                 small-step semantics, proving that both semantics are
                 equivalent. We then study the use of coinductive
                 big-step semantics in proofs of type soundness and
                 proofs of semantic preservation for compilers. A
                 methodological originality of this paper is that all
                 results have been proved using the Coq proof assistant.
                 We explain the proof-theoretic presentation of
                 coinductive definitions and proofs offered by Coq, and
                 show that it facilitates the discovery and the
                 presentation of the results. (See
                 \verb|http://gallium.inria.fr/~xleroy/coindsem/| for
                 the Coq on-machine formalization of these results.)",
  xtopic =       "mechsem",
  annote =       "This little gem was one I used in the draft version in
                 my Bachelors thesis",
}

@Misc{leroy:compcert,
  author =       "Xavier Leroy",
  title =        "The {Compcert} verified compiler, commented {Coq}
                 development",
  month =        mar,
  year =         "2008",
  xtopic =       "compcert",
  howpublished = "Available at \url{http://compcert.inria.fr/doc/}",
}

@Book{milner.tofte.ea:definition,
  abstract =     "Standard ML is a general-purpose programming language
                 designed for large projects. This book provides a
                 formal definition of Standard ML for the benefit of all
                 concerned with the language, including users and
                 implementers. Because computer programs are
                 increasingly required to withstand rigorous analysis,
                 it is all the more important that the language in which
                 they are written be defined with full rigor. One
                 purpose of a language definition is to establish a
                 theory of meanings upon which the understanding of
                 particular programs may rest. To properly define a
                 programming language, it is necessary to use some form
                 of notation other than a programming language. Given a
                 concern for rigor, mathematical notation is an obvious
                 choice. The authors have defined their semantic objects
                 in mathematical notation that is completely independent
                 of Standard ML. In defining a language one must also
                 define the rules of evaluation precisely--that is,
                 define what meaning results from evaluating any phrase
                 of the language. The definition thus constitutes a
                 formal specification for an implementation. The authors
                 have developed enough of their theory to give sense to
                 their rules of evaluation. The Definition of Standard
                 ML is the essential point of reference for Standard ML.
                 Since its publication in 1990, the implementation
                 technology of the language has advanced enormously and
                 the number of users has grown. The revised edition
                 includes a number of new features, omits little-used
                 features, and corrects mistakes of definition.",
  author =       "Robin Milner and Mads Tofte and Robert Harper and
                 David Macqueen",
  citeulike-article-id = "113339",
  howpublished = "Paperback",
  ISBN =         "0-262-63181-4",
  keywords =     "ml, programming",
  month =        may,
  posted-at =    "2007-04-19 12:49:22",
  priority =     "2",
  publisher =    "The MIT Press",
  title =        "The Definition of Standard {ML} - Revised",
  URL =          "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0262631814",
  year =         "1997",
  annote =       "I do not own this, but I should",
}

@InProceedings{morita.yamaguchi:universal,
  author =       "Kenichi Morita and Yoshikazu Yamaguchi",
  title =        "A Universal Reversible Turing Machine",
  booktitle =    "MCU",
  year =         "2007",
  pages =        "90--98",
  ee =           "http://dx.doi.org/10.1007/978-3-540-74593-8_8",
  crossref =     "durand-lose.margenstern:machines",
  bibsource =    "DBLP, http://dblp.uni-trier.de",
}

@Book{pierce:advanced,
  abstract =     "The study of type systems for programming languages
                 now touches many areas of computer science, from
                 language design and implementation to software
                 engineering, network security, databases, and analysis
                 of concurrent and distributed systems. This book offers
                 accessible introductions to key ideas in the field,
                 with contributions by experts on each topic.<br /> <br
                 /> The topics covered include precise type analyses,
                 which extend simple type systems to give them a better
                 grip on the run time behavior of systems; type systems
                 for low-level languages; applications of types to
                 reasoning about computer programs; type theory as a
                 framework for the design of sophisticated module
                 systems; and advanced techniques in ML-style type
                 inference.<br /> <br /> <i>Advanced Topics in Types and
                 Programming Languages</i> builds on Benjamin Pierce's
                 <i>Types and Programming Languages</i> (MIT Press,
                 2002); most of the chapters should be accessible to
                 readers familiar with basic notations and techniques of
                 operational semantics and type systems -- the material
                 covered in the first half of the earlier book.<br />
                 <br /> <i>Advanced Topics in Types and Programming
                 Languages</i> can be used in the classroom and as a
                 resource for professionals. Most chapters include
                 exercises, ranging in difficulty from quick
                 comprehension checks to challenging extensions, many
                 with solutions.",
  author =       "Benjamin C. Pierce",
  citeulike-article-id = "105559",
  howpublished = "Hardcover",
  ISBN =         "0-262-16228-8",
  keywords =     "dependent-types, functional-programming, type-theory",
  month =        nov,
  posted-at =    "2008-02-26 14:24:06",
  priority =     "3",
  publisher =    "MIT Press",
  title =        "Advanced Topics In Types And Programming Languages",
  URL =          "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0262162288",
  year =         "2004",
  annote =       "I have not read this one yet, but should!",
}

@Book{pierce:2002:types,
  abstract =     "A type system is a syntactic method for automatically
                 checking the absence of certain erroneous behaviors by
                 classifying program phrases according to the kinds of
                 values they compute. The study of type systems--and of
                 programming languages from a type-theoretic
                 perspective-has important applications in software
                 engineering, language design, high-performance
                 compilers, and security.<br /> <br /> This text
                 provides a comprehensive introduction both to type
                 systems in computer science and to the basic theory of
                 programming languages. The approach is pragmatic and
                 operational; each new concept is motivated by
                 programming examples and the more theoretical sections
                 are driven by the needs of implementations. Each
                 chapter is accompanied by numerous exercises and
                 solutions, as well as a running implementation,
                 available via the Web. Dependencies between chapters
                 are explicitly identified, allowing readers to choose a
                 variety of paths through the material.<br /> <br /> The
                 core topics include the untyped lambda-calculus, simple
                 type systems, type reconstruction, universal and
                 existential polymorphism, subtyping, bounded
                 quantification, recursive types, kinds, and type
                 operators. Extended case studies develop a variety of
                 approaches to modeling the features of object-oriented
                 languages.",
  author =       "Benjamin C. Pierce",
  citeulike-article-id = "105547",
  howpublished = "Hardcover",
  ISBN =         "0-262-16209-1",
  keywords =     "type-theory",
  month =        mar,
  posted-at =    "2008-02-26 14:24:32",
  priority =     "0",
  publisher =    "MIT Press",
  title =        "Types and Programming Languages",
  URL =          "http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0262162091",
  year =         "2002",
  annote =       "Really good book. A bit simple perhaps, but it
                 describes the issues of type systems really well. I
                 enjoyed reading it.",
}

@Unpublished{pottier.rémy:essence,
  author =       "François Pottier and Didier Rémy",
  title =        "The Essence of {ML} Type Inference",
  year =         "2003",
  note =         "Extended preliminary version of
                 \CITE{pottier-remy/emlti}",
  html =         "http://cristal.inria.fr/attapl/",
  psgz =         "http://cristal.inria.fr/attapl/preversion.ps.gz",
}

@Book{schurmann.pfenning:1999:twelf,
  author = 	 {Frank Pfenning and Carsten Sch{\"u}rmann},
  editor = 	 {},
  title = {{S}ystem {D}escription: {T}welf - {A} {M}eta-{L}ogical {F}ramework for {D}eductive {S}ystems},
  publisher = 	 {Springer},
  pages = {679-},
  year = 	 {1999},
  volume = 	 {1632/1999},
  series = 	 {Lecture Notes in Computer Science (LNCS)},
  isbn = {978-3-540-66222-8},
  doi = {10.1007/3-540-48660-7_14}
}

@Misc{twelfwiki:2007,
  author =       "Carsten Sch{\"u}rmann and Frank Pfenning et.al",
  title =        "The Twelf Wiki",
  howpublished = "at \url{http://twelf.plparty.org}",
  year =         "2005--2009",
}

@Misc{team:coq,
  title =        "The Coq Faq",
  howpublished = "\url{http://coq.inria.fr/V8.1/faq.html}",
  author =       "Coq development team",
}

@Misc{team:coq*1,
  author =       "Coq development team",
  title =        "Coq Proof Assistant",
  howpublished = "available at \url{http://coq.inria.fr/}",
  year =         "1989--2009",
}

@Book{thorup:algebra,
  author =       "Anders Thorup",
  title =        "Algebra",
  publisher =    "Universitetsbogladen",
  year =         "2007",
  OPTkey =       "",
  OPTvolume =    "",
  OPTnumber =    "",
  OPTseries =    "",
  OPTaddress =   "",
  OPTedition =   "",
  OPTmonth =     "",
  ISBN =         "87-91180-28-7",
  annote =       "This book was the one I used when I first learned
                 algebra. Written in Danish, it is one of the best books
                 I've read as an introductory book to the subject",
}

@InProceedings{yokoyama.axelsen.ea:principles,
  author =       "Tetsuo {Yokoyama,} and Holger Bock {Axelsen,} and
                 Robert {Gl{\"{u}}ck,}",
  title =        "Principles of a reversible programming language",
  booktitle =    "CF '08: Proceedings of the 2008 Conference on
                 Computing Frontiers",
  year =         "2008",
  ISBN =         "978-1-60558-077-7",
  pages =        "43--54",
  location =     "Ischia, Italy",
  doi =          "http://doi.acm.org/10.1145/1366230.1366239",
  publisher =    "ACM",
  annotate =     "Robert and Holgers work on the reversible language
                 JANUS with Tetsou Yokoyama. The paper is going ahead
                 faster than glueck+2007, and has a more overview-feel
                 to it. On the other hand it provides changes to the
                 semantics which alters the language in important
                 ways.",
}

@InProceedings{yokoyama.gluck:reversible,
  author =       "Tetsuo {Yokoyama,} and Robert {Gl{\"{u}}ck,}",
  title =        "A reversible programming language and its invertible
                 self-interpreter",
  booktitle =    "PEPM '07: Proceedings of the 2007 ACM SIGPLAN
                 Symposium on Partial Evaluation and Semantics-based
                 Program Manipulation",
  year =         "2007",
  ISBN =         "978-1-59593-620-2",
  pages =        "144--153",
  location =     "Nice, France",
  doi =          "http://doi.acm.org/10.1145/1244381.1244404",
  publisher =    "ACM",
}

@Book{appel:1998:modern,
  author =       "Andrew W. Appel",
  title =        "Modern Compiler Implementation in {ML}",
  publisher =    "Cambridge University Press",
  year =         "1998",
  ISBN =         "0-521-58274-1",
}

@article{appel:1998:ssa,
 author = {Appel, Andrew W.},
 title = {{SSA} is functional programming},
 journal = {SIGPLAN Not.},
 volume = {33},
 number = {4},
 year = {1998},
 issn = {0362-1340},
 pages = {17--20},
 doi = {http://doi.acm.org/10.1145/278283.278285},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@Book{mogensen:2008:basics,
  author =       "Torben Æ. Mogensen",
  title  =       "Basics of Compiler Design",
  year   =       "2008",
  isbn   =       {978-87-993154-0-6},
  note   =       {Available at \url{http://www.diku.dk/hjemmesider/ansatte/torbenm/Basics/}},
  publisher = "Lulu"
}



@TechReport{warren:1983:prolog,
  author = 	 {David {H}. {D}. Warren},
  title = 	 {An abstract {P}rolog instruction set},
  institution =  {{SRI} {I}nternational},
  year = 	 {1983},
  OPTtype = 	 {},
  number = 	 {Technical Note 301},
  address = 	 {Menlo Park, CA},
  month = 	 {October},
  note = 	 {\url{http://www.ai.sri.com/pubs/files/641.pdf}},
}

@inproceedings{morrisett.crary.ea:1999:talx86,
  author = {Greg Morrisett and Karl Crary and Neal Glew and Dan Grossman and Richard Samuels and Frederick Smith and David Walker and Stephanie Weirich and Steve Zdancewic},
  title = {TALx86: A realistic typed assembly language},
  booktitle = {In Second Workshop on Compiler Support for System Software},
  year = {1999},
  pages = {25--35},
  abstract = {The goal of typed assembly language (TAL) is to provide a low-level, statically typed target language that is better suited than Java bytecodes for supporting a wide variety of source languages and a number of important optimizations. In previous work, we formalized idealized versions of TAL and proved important safety properties about them. In this paper, we present our progress in defining and implementing a realistic typed assembly language called TALx86. The TALx86 instructions comprise a relatively complete fragment of the Intel IA32 (32-bit 80x86 flat model) assembly language and are thus executable on processors such as the Intel Pentium. The type system for the language incorporates a number of advanced features necessary for safely compiling large programs to good code.

To motivate the design of the type system, we demonstrate how various high-level language features are compiled to TALx86. For this purpose, we present a type-safe C-like language called Popcorn.},
  pdf = {http://www.eecs.harvard.edu/~greg/papers/talx86-wcsss.pdf},
  annote = {Need to read this beast}
}

@Book{lindholm.frank:1999:jvm,
    abstract = {{If you're writing a Java bytecode interpreter--or a compiler that generates binary files for such an interpreter--<I>The Java Virtual Machine Specification</I> has the information you need. It's the definitive document on Java compilers and runtime environments.<p> The first part of <I>The Java Virtual Machine Specification</I> discusses the relationships among Java program elements like objects, variables, data types, arrays, exceptions and threads, and compile and run time. Implementers of Java compilers and interpreters need to understand this stuff, but it also makes fascinating reading for Java programmers--it'll help with writing more efficient applications.<p> From there, the authors dig into the binary .class file format. They provide information on creating such a file as output from a Java compiler, and also give lots of data on how a Java interpreter should examine a .class file to verify its validity and trustworthiness. The authors explain how to carry out loading and linking operations on the objects a .class file defines. <p> The latter half of <I>The Java Virtual Machine Specification</I> is pure reference--it's a list of all Java opcodes, their purposes, formats, and accepted operands. There's also information about the exceptions each opcode can throw during compilation and execution.<p> Helpfully, the authors provide a peek at how Sun's Java compiler (javac) and Java interpreter (java) work, complete with source code. These examples promise to provide developers with hints as they implement their own compilers and runtime environments. <I>--David Wall</I>} { The nucleus of the Java programming language, the Java Virtual Machine is the technology responsible for Java's cross-platform delivery, the small size of its compiled code, and its security capabilities.   <P>Written by its designers and implementors, this book represents the complete and definitive specification for the Java Virtual Machine. It is an essential reference for compiler writers and Java Virtual Machine implementors. For all Java programmers, the book offers a unique and fascinating internal view of how Java really works.   <P>In this book, you will find comprehensive coverage of the Java Virtual Machine class file format and instruction set. In addition, directions for compiling for the Java Virtual Machine with numerous practical examples clarify how the Java Virtual Machine operates in practice. The book also demonstrates the Java Virtual Machine's powerful verification techniques. In all, the book provides sufficient detail to enable you to implement your own fully-compatible Java Virtual Machine.}},
    author = {Lindholm, Tim and Yellin, Frank},
    citeulike-article-id = {1270137},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&amp;path=ASIN/0201432943},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21&amp;path=ASIN/0201432943},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21&amp;path=ASIN/0201432943},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0201432943},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0201432943/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0201432943},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0201432943},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0201432943},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0201432943&index=books&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0201432943},
    edition = {2},
    howpublished = {Paperback},
    isbn = {0201432943},
    keywords = {--},
    month = {April},
    posted-at = {2007-05-01 15:09:33},
    priority = {2},
    publisher = {Prentice Hall PTR},
    title = {Java(TM) Virtual Machine Specification, The (2nd Edition)},
    url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0201432943},
    year = {1999}
}



@Misc{http:cminmin,
  key = {cminmin},
  title = 	 {The {C-\ \!\!-} homepage},
  howpublished = {\url{http://www.cminusminus.org/}},
}

@Manual{lattner.ea:2009:llvm-ref,
  title = 	 {LLVM Language Reference Manual},
  author = 	 {Chris Lattner and Vikram Adve},
  month = 	 {Aug},
  year = 	 2009,
  note = 	 {From \url{http://llvm.org/docs/LangRef.html}}
}

@Book{Ecma:2006:335,
  author = {{ECMA} International},
  publisher= {{ECMA} International},
  edition = {4},
  interHash = {1dc2e9045b7eb0141590e4ec0e1fda3b},
  intraHash = {bae3db7d698436c276f984a75ba1f5ce},
  title = {Standard ECMA-335 - Common Language Infrastructure (CLI)},
  url = {http://www.ecma-international.org/publications/standards/Ecma-335.htm},
  note = {\url{http://www.ecma-international.org/publications/standards/Ecma-335.htm}},

  year = {2006},
  month = {June}
}

@INPROCEEDINGS{aydemir:2005:mechanizedmetatheory,
  author = {Brian E. Aydemir and Aaron Bohannon and Matthew Fairbairn
                  and J. Nathan Foster and Benjamin C. Pierce and Peter
                  Sewell and Dimitrios Vytiniotis and Geoffrey Washburn and
                  Stephanie Weirich and Steve Zdancewic},
  title = {Mechanized metatheory for the masses: {T}he {POPLmark}
                  Challenge},
  booktitle = {International Conference on Theorem Proving in
                  Higher Order Logics (TPHOLs)},
  year = 2005,
  month = {August},
  ps = {http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.ps},
  psgz = {http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.ps.gz},
  pdf = {http://www.cis.upenn.edu/~geoffw/research/papers/poplmark.pdf},
  plclub = {Yes},
  bcp = {Yes},
  keys = {poplmark},
  abstract = {How close are we to a world where every paper on
                  programming languages is accompanied by an electronic
                  appendix with machine-checked proofs?
                  We propose a concrete set of benchmarks for measuring
                  progress in this area. Based on the metatheory of System
                  F-sub, a typed lambda-calculus with second-order
                  polymorphism, subtyping, and records, these benchmarks
                  embody many aspects of programming languages that are
                  challenging to formalize: variable binding at both the term
                  and type levels, syntactic forms with variable numbers of
                  components (including binders), and proofs demanding
                  complex induction principles. We hope that these benchmarks
                  will help clarify the current state of the art, provide a
                  basis for comparing competing technologies, and motivate
                  further research.}
}
@book{knuth:1997:taocp1,
    abstract = {{This magnificent tour de force presents a comprehensive overview of a wide variety of algorithms and the analysis of them. Now in its third edition, <I>The Art of Computer Programming, Volume I: Fundamental Algorithms</I> contains substantial revisions by the author and includes numerous new exercises.<P> Although this book was conceived several decades ago, it is still a timeless classic. One of the book's greatest strengths is the wonderful collection of problems that accompany each chapter. The author has chosen problems carefully and indexed them according to difficulty. Solving a substantial number of these problems will help you gain a solid understanding of the issues surrounding the given topic. Furthermore, the exercises feature a variety of classic problems.<P> <I>Fundamental Algorithms</I> begins with mathematical preliminaries. The first section offers a good grounding in a variety of useful mathematical tools: proof techniques, combinatorics, and elementary number theory. Knuth then details the MIX processor, a virtual machine architecture that serves as the programming target for subsequent discussions. This wonderful section comprehensively covers the principles of simple machine architecture, beginning with a register-level discussion of the instruction set. A later discussion of a simulator for this machine includes an excellent description of the principles underlying the implementation of subroutines and co-routines. Implementing such a simulator is an excellent introduction to computer design.<P> In the second section, Knuth covers data structures--stacks, queues, lists, arrays, and trees--and presents implementations (in MIX assembly) along with techniques for manipulating these structures. Knuth follows many of the algorithms with careful time and space analysis. In the section on tree structures, the discussion includes a series of interesting problems concerning the combinatorics of trees (counting distinct trees of a particular form, for example) and some particularly interesting applications. Also featured is a discussion of Huffmann encoding and, in the section on lists, an excellent introduction to garbage collection algorithms and the difficult challenges associated with such a task. The book closes with a discussion of dynamic allocation algorithms.<P> The clear writing in <I>Fundamental Algorithms</I> is enhanced by Knuth's dry humor and the historical discussions that accompany the technical matter. Overall, this text is one of the great classics of computer programming literature--it's not an easy book to grasp, but one that any true programmer will study with pleasure.}},
    author = {Knuth, Donald E.},
    citeulike-article-id = {175024},
    citeulike-linkout-0 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20&amp;path=ASIN/0201896834},
    citeulike-linkout-1 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21&amp;path=ASIN/0201896834},
    citeulike-linkout-2 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21&amp;path=ASIN/0201896834},
    citeulike-linkout-3 = {http://www.amazon.jp/exec/obidos/ASIN/0201896834},
    citeulike-linkout-4 = {http://www.amazon.co.uk/exec/obidos/ASIN/0201896834/citeulike00-21},
    citeulike-linkout-5 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0201896834},
    citeulike-linkout-6 = {http://www.worldcat.org/isbn/0201896834},
    citeulike-linkout-7 = {http://books.google.com/books?vid=ISBN0201896834},
    citeulike-linkout-8 = {http://www.amazon.com/gp/search?keywords=0201896834&index=books&linkCode=qs},
    citeulike-linkout-9 = {http://www.librarything.com/isbn/0201896834},
    day = {07},
    howpublished = {Hardcover},
    isbn = {0201896834},
    keywords = {programming},
    month = {July},
    posted-at = {2005-04-30 16:57:47},
    priority = {2},
    publisher = {{Addison-Wesley}},
    title = {The Art of Computer Programming, Volume 1: Fundamental Algorithms (3rd Edition)},
    url = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20&path=ASIN/0201896834},
    year = {1997}
}

@Proceedings{conf/lics:2002,
  title     = {17th IEEE Symposium on Logic in Computer Science (LICS 2002),
               22-25 July 2002, Copenhagen, Denmark, Proceedings},
  booktitle = {LICS},
  publisher = {IEEE Computer Society},
  year      = {2002},
  isbn      = {0-7695-1483-9},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@Inproceedings{reynolds:2002:separationlogic,
    author = {John Reynolds},
    title = {Separation Logic: A Logic for Shared Mutable Data Structures},
    booktitle = {LICS},
    year = {2002},
    isbn = {0-7695-1483-9},
    pages = {55--74},
    publisher = {IEEE Computer Society}
}

@book{winskel:1993:formal,
    author = {Winskel, Glynn},
    citeulike-article-id = {278037},
    howpublished = {Paperback},
    isbn = {0262731037},
    keywords = {book, programming, programming\_languages, semantics},
    month = {February},
    priority = {2},
    publisher = {The MIT Press},
    title = {Formal Semantics of Programming Languages},
    year = {1993}
}

