\documentclass[a4paper, oneside, 10pt, draft]{memoir}

\chapterstyle{culver}
\RequirePackage[english]{jlouis}

\author{Jesper Louis
  Andersen\\jesper.louis.andersen@gmail.com\\140280-2029}
\title{Formalizing a Virtual Machine}
\date{\today}

\newlength{\drop}
\newcommand*{\titleM}{\begingroup% Misericords, T&H p 153
  \drop = 0.08\textheight
  \centering
  {\Huge\bfseries Lambda}\\[\baselineskip]
  {\scshape IR of exsml}\\[\baselineskip]
  {\scshape by}\\[\baselineskip]
  {\large\scshape Jesper Louis Andersen\\jesper.louis.andersen@gmail.com}\par
  \endgroup}

\bibliographystyle{plain}

\begin{document}
\listoffixmes{}
\maketitle{}
\newpage{}
\tableofcontents{}
\newpage{}
\chapter{Introduction}

It is well known in compiler construction, that intermediate languages
are a useful and beneficial abstraction\cite{appel:1998:modern,
  mogensen:2008:basics}. Rather than targeting the instruction set
architecture directly, the compiler constructor first targets an
intermediate language (IL). Then the IL and is afterwards compiled to
the target machines instruction set\footnote{Sans
  optimizations. Optimization is usually carried out on the IL as
  well}. Schematically, the phases can be described as:
\begin{equation*}
  L ->^{fe} IL ->^{be} Q
\end{equation*}
where $L$ is the source language, the arrow marked by $fe$ the
front-end compilation, and the arrow marked by $be$ is the back-end
compilation onto the machine language $Q$. The construction is
advantageous because the compiler writer can share either the
front-end among several back-ends or the back-end among several
front-ends.

A popular extension of this strategy is to stage the compilation
in two parts: the front-end delivers IL code which is then typically
encoded in a binary format for transport. Arriving at the target
machine, this \emph{bytecode} is either interpreted, compiled or a
mixture of both. Usually, the run-time responsible for executing the
back-ends part is named a ``Virtual Machine'' (VM) because the IL is
regarded as a machine abstraction.

ILs are usually designed to make front-end construction easier. The IL
can specifically factor out details of the underlying machine thus
simplifying compiler implementation. As an example most VMs carries
out register allocation and the programmer is given an abstraction:
either a stack or an infinite set of registers. Some VMs are designed
with a fairly broad IL intended to capture many different language
types while others are more constrained, often tied to a single
intended language. Examples of the former are the Java JVM
runtime\cite{lindholm.frank:1999:jvm} and the .NET
CLR/CIL\cite{ecma:2006:335}, while an example of the latter is the
Erlang Runtime System (a register machine with a built-in novel set of
concurrency primitives).

\section{LLVM}

This report concerns itself with a virtual machine named LLVM, the Low
Level Virtual Machine. It adopted this name because the LLVM IL is
close to an idealized assembly language with several convenient
differences of which we list some:
\begin{itemize}
\item All LLVM IL programs are statically typed. This rules out many
  common programming errors and fits well into compilations schemes
  where intermediate stage transforms are type-checked.
\item There is an infinite amount of registers and register allocation
  is carried out by the LLVM system.
\item Correct LLVM IL programs have the SSA-property: A variable has
  only one (static/syntactic) point in the program where it is
  \emph{defined}. All \emph{uses} of a variable must then be from this
  single static assignment. The usual $\phi$-node method is used to
  handle the case where control flow joins in the CFG.
\item LLVM has a built-in exception primitive.
\item LLVM is expected to carry out a large number of advanced
  optimizations on its IL with the intent of simplifying work for
  compiler writers.
\end{itemize}

However, one Achilles heel of the LLVM IL is the total lack of
formality. There is no EBNF of its grammar available and thus no
attempts have been made to define its semantics operationally.

In this report, we aim for a subset of the LLVM IL language and
provide a syntax description, an operational (small-step) semantics and a type
system. We seek to prove the system fulfills the usual meta-theoretical
properties of \emph{progress} and \emph{preservation} as well as
\emph{determinism}.

The state-of-the-art emphasized by for example the PoPLMark
challenge\cite{aydemir:2005:mechanizedmetatheory}, is the encoding of
syntax, semantics and proofs into a proof assistant or logical
framework. The goal is that every computer scientific report is
accompanied by a formal proof written such that the computer can
verify its correctness. In this report, every description has been
encoded into the logical framework of
Twelf\cite{schurmann.pfenning:twelf} for verification.

\section{Report structure}

The report first introduces some preliminaries and then presents the
real work made in the following chapters: syntax, semantics and
meta-theory of our Mini-LLVM language is presented. It is expected
that the reader is familiar with operational semantics, proof theory
and machine verifiable proofs; in particular the Twelf logical
framework. It is also expected that the reader is familiar with
SSA-form and its implications.

\chapter{Design considerations}

\fixme{This whole chapter needs more work as well}
In this section, we limit the scope of the formalization and present
the main design considerations before attempting to formalize the work.

\begin{figure}
\begin{verbatim}
if.else:
  %sub = sub i32 %n, 1
  %call = call i32 @tri(i32 %sub)
  %add = add nsw i32 %call, %n
  br label %return
return:
  %retval.0 = phi i32 [ 0, %if.then ], [ %add, %if.else ]
  ret i32 %retval.0

\end{verbatim}
  \caption{An example LLVM fragment}
  \label{fig:llvm-example-1}
\end{figure}

Figure \ref{fig:llvm-example-1} contains an example of a typical LLVM
basic blocks. It begins with a label, identifying the block. Then a
series of instructions follow and the block ends in an unconditional
branch to the label '\texttt{\%return}'. Local definitions in LLVM are
prefixed by a '\%' marker and global (top-level) names by an '@'
marker. The instructions \texttt{sub, call, } and \texttt{add}
informally acts like one would expect. The LLVM type system can be
seen in the type designation \texttt{i32}, a 32-bit integer and
finally, the '\texttt{nsw}' designation makes the result underdefined,
should signed overflow occur.

In the basic block for the return, we first do a $\phi$-node
assignment. These assignment are required to be at the very top of a
basic block and transfers the value from the appropriate basic block
depending on the control flow. The '\texttt{ret}' instruction
returns. Note that this fragment has the SSA property.

Since we would like to represent LLVM in a machine checkable form in
Twelf, we utilize a result first formulated explicitly by
Appel\cite{appel:1998:modern, appel:1998:ssa}: every SSA program has
an equivalent functional program. Thus our first design choice is to
represent the LLVM subset as a functional first order
program. Informally, we can transform a fragment
\begin{verbatim}
  %sub = sub i32 %n, 1
  %call = call i32 @tri(i32 %sub)
  ...
\end{verbatim}
of two instructions following each other into the functional fragment:
\begin{verbatim}
  let %sub = sub i32 %n, 1
  in let %call = call i32 @tri(i32 %sub)
     in ...
\end{verbatim}

Note how the lexical scoping rules binds the '\texttt{\%sub}' value
in the correct scope.

We handle the basic blocks as Appel: each basic block becomes a
function with formal parameters the $\phi$-node variables. A branch to
a basic-block then tail-calls the function with the variables needing
transfer as parameters. In the example, we would have a function
\begin{verbatim}
return (%retval) =
   ret %retval
\end{verbatim}
for the return-basic-block. And the branch to it would be
\begin{verbatim}
if.else (...) =
  ...
    br %return (%add)
\end{verbatim}
to designate that the value of '\texttt{\%add}' is the one that should
go to the first $\phi$-node.

\section{Extent of the formalization}

We limit the extent of the formalization to a small subset of
LLVM. First, we note the complete lack of any formal grammar for
the language means we have to begin from a clean slate. Thus,
establishing a small subset is more important as a first step towards
the goal.

We cut any heap-interaction. Specifically, we cut the ability to
load and store data to a heap. LLVM allows pointer arithmetic in the
heap which is hard to handle meta-theoretically. We also cut a large
number of operations that would be easy to add but does not provide
any further insight. Conversion operations are not going to be
considered, as they contain a potentially unsafe '\texttt{bitcast}'
operation. ``Aggregate'' and ``Vector'' operations are not going to be
considered (these include structs and arrays). Finally, we won't be
considering instructions handling exceptions.

While the list seems extensive, it is important to stress that part of
the task is to understand the subset that is left to a level where it
can be put into a formal system.

Under the course of development, we will use LLVM version 2.x. We
mention this because LLVM is only supposed to change in a backwards
compatible way as long as it remains a version 2.x.

\chapter{Syntax of Mini-LLVM}

\newcommand{\variables}{\mathrm{Variables}}
\newcommand{\BBlabels}{\mathrm{BB Labels}}
\newcommand{\tnat}{\mathbf{nat}}
\newcommand{\tbool}{\mathbf{bool}}
\newcommand{\types}{\mathrm{Types}}
\newcommand{\typelist}{\mathrm{Type lists}}
\newcommand{\bbtype}{\mathrm{BB Type}}
\newcommand{\ftype}{\mathrm{Fun Contexts}}
\newcommand{\tpenv}{\mathrm{Var Contexts}}
\newcommand{\bbenv}{\mathrm{BB Contexts}}
\newcommand{\bor}{\; \vert \;}

\begin{figure}
  \begin{align*}
    \types \ni \tau & ::= \tnat \bor \tbool \\
    \typelist \ni [\tau] & ::= \cdot \bor \tau -> [\tau] \\
    \bbtype \ni Bb \tau   & ::= [\tau] & \text{Notation:} \; \tau -> \dotsc -> \tau' -> \cdot\\
    \ftype \ni D & ::= \cdot \bor (f \mapsto (\tau_1 -> \dotsc ->
    \tau_n), D) \\
    \tpenv \ni \Gamma & ::= \cdot \bor (x \mapsto \tau),\Gamma\\
    \bbenv \ni \Psi   & ::= \cdot \bor (bb \mapsto [Bb \tau_1, \dotsc Bb
    \tau_n]),\Psi
  \end{align*}
  \caption{Type system}
  \label{fig:type-system}
\end{figure}

In this section, we present the syntax of Mini-LLVM in a formal BNF
grammar. We also describe the type system as well as the basic domains
from which we draw values.

\section{Types and domains}

\paragraph{Types} The language employs a simple type system as in
figure \ref{fig:type-system}. There are two primitive base types,
natural numbers and boolean values. For handling passing of parameters
between basic blocks via $\phi$-nodes, there is a $\bbtype$
designation stating a (possibly empty) list of formal parameters. We
notate such lists as $\tau -> \dotsc \tau' -> \cdot$ where the last
``$\cdot$'' states that it is a function but without return type.

The choice of two primitive types is deliberate. It is the simplest
non-trivial choice of types possible. Had there only been one base
type, all typing degenerates into questions on type arity in basic
block definitions.

\newcommand{\numbers}{\mathrm{Numbers}}
\newcommand{\booleans}{\mathrm{Booleans}}
\newcommand{\funlabels}{\mathrm{Function\; labels}}
\newcommand{\nat}{n}
\newcommand{\bool}{b}
\newcommand{\BB}{\mathbb{B}}
\newcommand{\btrue}{\mathbf{True}}
\newcommand{\bfalse}{\mathbf{False}}

\paragraph{Domains}

Our language will be using several syntactic domains, the existence of
which we assume (figure \ref{fig:syntactic-domains}). We have
variables, $x_1, x_2, \dotsc$ used for naming and discriminating
registers from each others. For simplicity we restrict the language to
natural numbers only. This restriction is due to Twelf: we need to
encode the system of numbers and Peano-style natural numbers are
fairly simple to work with and handle. Verification in other systems
might have chosen another domain. We only utilize basic properties of
arithmetic in our verification, hence it might be possible to change
this later on.
\begin{figure}
  \begin{align*}
    \variables \ni V & ::= x_1, x_2, \dotsc \\
    \numbers \ni \NN, \nat & ::= 0 \bor 1 \bor 2 \bor \dotsc\\
    \booleans \ni \BB, \bool & ::= \btrue \bor \bfalse \\
    \BBlabels \ni bb & ::= bb_1, bb_2, bb_3, \dotsc \\
    \funlabels \ni f,g & ::= f,g,h,\dotsc
  \end{align*}
  \caption{Syntactic domains}
  \label{fig:syntactic-domains}
\end{figure}

Boolean values are either the true value or the false
value. Internally these are encoded as the natural numbers $0$ and
$1$, but the type system is intended to restrict the use to these
values only. Finally, we assume a set of Basic Block names. These are used to refer
to groups of basic blocks.

\fixme{Describe call}
\fixme{Add call to syntax}
\fixme{Describe $\Phi$ as an environment}
The LLVM IL severely limits extent where one is allowed to use a
specific syntactic class. This is probably due to the ILs heritage; it
is essentially an imperative, typed assembly language. In the course
of development, we started with a language more closely resembling a
functional language and then gradually stratified the syntactic
classes until it matched that of LLVM as much as possible.

Of course, since LLVM has no formal description and the informal
description lacks precision\cite{lattner.ea:2009:llvm-ref}, we run the
risk of having mistaken something in the definition.

\newcommand{\registers}{\mathrm{Registers}}
\newcommand{\constants}{\mathrm{Constants}}
\newcommand{\operations}{\mathrm{Operations}}
\newcommand{\instructions}{\mathrm{Instructions}}
\newcommand{\programs}{\mathrm{Programs}}
\newcommand{\definitions}{\mathrm{Definitions}}
\newcommand{\basicblocks}{\mathrm{Basic Blocks}}
\newcommand{\iret}[1]{\mathbf{ret} \; #1}

\newcommand{\ibr}[2]{\mathbf{br} \; #1 \; #2}
\newcommand{\ibrc}[5]{\mathbf{brc} \; #1 \; #2 \; #3 \; #4 \; #5}
\newcommand{\ilet}[3]{\mathbf{let} \; #1 = #2 \; \mathbf{in} \; #3}
\newcommand{\iletrec}[3]{\mathbf{letrec} \; #1 = #2 \; \mathbf{in} \; #3}
\newcommand{\ido}[3]{\mathbf{do} \; #1 = #2 \; \mathbf{in} \; #3}
\newcommand{\icall}[4]{\mathbf{call} \; #1 = #2 #3\; \mathbf{in} \;
  #4}
\newcommand{\ipgm}[2]{\mathbf{Def} \; #1 \; \mathbf{in} \; #2}
\begin{figure}
  \begin{align*}
    \registers \ni r & ::= x_1, x_2, x_3, \dotsc\\
    \constants \ni c & ::= \; r \bor \nat \bor \bool \\
    \operations \ni op & ::= c \\
                       & \bor \quad c + c \\
                       & \bor \quad c - c \\
                       & \bor \quad c < c \\
   \basicblocks \ni d  & ::= \lambda (x_1, x_2, \cdots, x_n) . i\\
   \instructions \ni i & ::= \iret{c} \\
                       & \bor \quad \ibr{bb^n}{(c_1, \dotsc, c_n)} \\
                       & \bor \quad \ibrc{c}{bb^n}{(c_1, \dotsc, c_n)}{bb^n}{(c'_1, \dotsc, c'_n)}\\
                       & \bor \quad \ilet{r}{op}{i} \\
                       & \bor \quad \iletrec{bb}{(d_1, d_2, \dotsc, d_n)}{i} \\
                       & \bor \quad \ido{r}{i_1}{i_2} &
                       (\text{Internal})\\
                       & \bor \quad \icall{r}{f}{(c_1, \dotsc,
                         c_n)}{i}\\
    \definitions \ni \Phi & ::= \cdot \bor (f(x_1, \dotsc, x_n) = i, \Phi)\\
    \programs \ni p & ::= \ipgm{\Phi}{i}
  \end{align*}
  \caption{Syntax}
  \label{fig:syntax}
\end{figure}

\section{Main syntax}

In figure \ref{fig:syntax} we present the complete syntax for the
Mini-LLVM language. An LLVM register '\%x' is mapped onto a set of
registers $x_1, \dotsc$. The constants of the language are exactly
registers, natural numbers and boolean values. The language has three
primitive operations, namely $c + c$, $c - c$ and $c < c$. Of these,
the latter returns a boolean value, whereas the first two return
natural numbers. The '$-$' operation is defined such that if $y \geq x$
then $x - y = 0$.

The main part of Mini-LLVM are the instructions. The instruction
$\iret{v}$ represents returning a value from a function. It models the
LLVM '\texttt{ret}' instruction. The instruction $\ibr{bb^k}{(c_1,
  \dotsc, c_n)}$ designates an unconditional branch to the $k$th
projection in the basic block bundle represented by the name $bb$. The
parameters $c_1$ through $c_n$ are formal $\phi$-node parameters to
the given basic block. In LLVM, the projections are named explicitly
by identifier names, but we felt that a projection is easier to handle
from a formal viewpoint.

The $\ibrc{x}{bb^k}{Ps}{bb^{k'}}{Ps'}$ represents a conditional
branch. It will, depending on the value of $x$ transfer control to
either the first or second basic block projection, injecting the
corresponding set of $\phi$-node parameters. In LLVM both
branch-instructions are called '\texttt{br}' -- the syntactical
difference discriminates them.

As noted in the design considerations, we represent a sequential chain
of operations as a chain of let-style-bindings. Thus the
$\ilet{x}{op}{i}$ instruction represents sequential execution. An
operation is executed and its result is placed into the register
$x$. The register is then available in the $i$ instruction.

Basic blocks are introduced with the $\iletrec{bb}{(d_1, \dotsc,
  d_n)}{i}$ notation. This simultaneously binds the definitions $d_1$
through $d_n$ of basic blocks to the name $bb$. Note each definition will
take formal parameters for its $\phi$-nodes. The name $bb$ will be
available in the context of the instruction $i$.

The $\ido{x}{i_1}{i_2}$ instruction is not meant to be present in
initial Mini-LLVM programs. It is used internally to keep the context
of a function call around. This has to do with the fact that the
formalization lacks a stack and thus uses the current continuation
context to keep track of where the computation came from. Function
calls utilize the instruction while they are executing.\fixme{Ouch,
  this is disturbing w.r.t inter-function BB applications}.

Finally the $\icall{r}{f}{(c_1, \dotsc, c_n)}{i}$ instruction
represents an LLVM '\texttt{call}' instruction in a very simplified
way. In LLVM it is possible to annotate the call-instruction with a
large number of hints. These hints are used to handle calling
conventions, tall-call applicability, etc., but we omit them in our
formalization because we do not attempt to formalize these aspects of
LLVM. The instruction will call the $f$ function with parameters $c_1$
through $c_n$ returning the result in the $r$ register. The result
will be available in the $i$ instruction. Thus a function call acts
like a special variant of a let-binding.

\paragraph{Programs}

A Mini-LLVM program is a list of definitions $\Phi$ together with an
initial instruction $i$. The notation is $\ipgm{\Phi}{i}$. Usually, we
expect the program to begin by calling a main-function in the list of
definitions, but we have chosen to deviate from LLVM here and allow
the execution of an arbitrary instruction rather a call to main.

\chapter{Mini-LLVM type sytem}

In this chapter we describe a type system for our Mini-LLVM
language. There are several examples of syntactical problems in the
syntax alone. It is for example possible to use a natural number as a
constant $c$ in $\ibrc{c}{...}{}{}{}$, which is obviously incorrect as
per our semantics, we define later. Another problem might be that
$\ilet{r}{op}{i}$ has a type $\tau$ for the register $r$ but its use
in $i$ is of type $\tau'$ different from $\tau$.

\newcommand{\tpr}{|-_{r}}
\newcommand{\tpc}{|-_{c}}
\newcommand{\tpop}{|-_{o}}
\newcommand{\tpb}{|-_{b}}

To take care of these problems, we need a type system ruling out these
possibilities in the syntax. In figure \ref{fig:type-judgement-1}, we
present typing relations for registers, constants and
operations. Register typing is simply handled by a judgment form
$\boxed{\Gamma \tpr x}$ with a single rule, TpR, for lookup into the
environment. The judgement form $\boxed{\Gamma \tpc c : \tau}$ states
that in the environment of $\Gamma$ the constant $c$ has type
$\tau$. There are 3 different cases, one for register lookup, and two
for each of the constant types. It is implicitly the case that the $n$
and $b$ are a natural number and boolean value respectively.

The judgment form for operations is $\boxed{\Gamma \tpop op :
  \tau}$. Under the environment of $\Gamma$ the operation $op$ has
type $\tau$. These rules are somewhat straightforward for most
part. The only special case is that the less-than comparison operator
has boolean type.

Basic blocks are typed by checking that each of the formal parameters
have the stated type as a parameter and in the instruction body. Note
that we do not consider the return type of the instruction as we
handle it later on when type checking functions.

\begin{figure}
  \begin{gather*}
    \text{Registers:} \quad \boxed{\Gamma \tpr x : \tau}\\
    \inference[TpR]{\Gamma(x) = \tau}{\Gamma \tpr x : \tau}
  \end{gather*}
  \begin{gather*}
    \text{Constants:} \quad \boxed{\Gamma \tpc c : \tau}\\
    \inference[TpC-Var]{\Gamma \tpr x}{\Gamma \tpc x : \tau}\\
    \inference[TpC-Nat]{}{\Gamma \tpc n : \tnat} \quad
    \inference[TpC-Bool]{}{\Gamma \tpc b : \tbool}
  \end{gather*}
  \begin{gather*}
    \text{Operations:} \quad \boxed{\Gamma \tpop op : \tau} \\
    \inference[TpOp-Cst]{\Gamma \tpc c : \tau}{\Gamma |- c : \tau}\\\\
    \inference[TpOp-Plus]{\Gamma \tpop o_1 : \tnat \quad \Gamma
      \tpop o_2 : \tnat}{\Gamma \tpop o_1 + o_2 : \tnat} \quad
    \inference[TpOp-Mone]{\Gamma \tpop o_1 : \tnat \quad \Gamma
      \tpop o_2 : \tnat}{\Gamma \tpop o_1 - o_2 : \tnat}\\\\
    \inference[TpOp-Let]{\Gamma \tpop o_1 : \tnat \quad \Gamma
      \tpop o_2 : \tnat}{\Gamma \tpop o_1 < o_2 : \tbool}
  \end{gather*}
  \begin{gather*}
    \text{Basic block Definitions:} \quad \boxed{D;\Psi;\Gamma \tpb d
      : \tau}\\
    \inference[BB-Def]{\Gamma |- x_1 : \tau_1 \quad \dotsb \quad
      \Gamma |- x_n : \tau_n\\
    D;\Psi;\Gamma[x_1 \mapsto \tau_1 \dotsb x_n \mapsto \tau_n] |- i :
  \tau}{D;\Psi;\Gamma \tpb \lambda(x_1, x_2, \dotsc,
      x_n).i : \tau_1 -> \tau_2 -> \dotsc -> \tau_n -> \cdot}
  \end{gather*}
  \caption{Typing 1}
  \label{fig:type-judgement-1}
\end{figure}

In figure \ref{fig:type-judgement-2} we present the typing relations
for instructions. The general judgment for these is
$\boxed{D;\Psi;\Gamma |- i : \tau}$. This specifies that the
instruction $i$ has a type of $\tau$ in the environment of
$D;\Psi;\Gamma$. The domain $D$ here is the domain of function
contexts (see figure \ref{fig:type-system}) mapping a function name
$f$ to its function type. The domain $\Psi$ maps basic blocks: for
each basic block there is a mapping from the basic block name to a
tuple of basic block types. Finally, the domain $\Gamma$ maps
registers to their types.

An instruction of the form $\iret{r}$ has type $\tau$ if the constant
it returns has. Correct typing of an $\ilet{x}{op}{i}$ instruction
requires that the operation $op$ returns the same type as is used for
the register $x$ in the body $i$.

\begin{figure}
  \begin{gather*}
    \text{Instructions:} \quad \boxed{D ; \Psi ; \Gamma |- i : \tau}\\\\
    \inference[Tp-ret]{\Gamma \tpc c : \tau}{D ; \Psi ;
      \Gamma |- \iret{c} : \tau} \quad
    \inference[Tp-let]{\Gamma \tpop op : \tau_1 \quad D ; \Psi ;
      \Gamma[x \mapsto \tau_1] |- i : \tau}{D ; \Psi ; \Gamma |-
      \ilet{x}{op}{i} : \tau}\\\\
    \inference[Tp-do]{D;\Psi;\Gamma |- i_1 : \tau_1 \quad
      D;\Psi;\Gamma[x \mapsto \tau_1] |- i_2 : \tau} {D;\Psi;\Gamma |-
      \ido{x}{i_1}{i_2} : \tau}\\\\
    \inference[Tp-br]{\Psi(bb^n) = \tau_1 -> \tau_2 -> \dotsc ->
      \tau_n -> \cdot\\
      c_1 : \tau_1 \quad c_2 : \tau_2 \quad \dotsb \quad c_n : \tau_n}
    {D;\Psi;\Gamma |- \ibr{bb^k}(c_1, c_2, \dotsc, c_n) : \tau}\\\\
    \inference[Tp-brc]{\Gamma \tpc x : \tbool \\ D;\Psi;\Gamma |-
      \ibr{bb^k}{(c_1, \dotsc c_n)} : \tau \\
    D;\Psi;\Gamma |- \ibr{bb^{k'}}{(c'_1, \dotsc, c'_{n'})} : \tau}{D;\Psi;\Gamma |- \ibrc{x}{bb^k}{(c_1, \dotsc,
        c_n)}{bb^{k'}}{(c'_1, \dotsc, c'_{n'})} : \tau} \\\\
    \inference[Tp-letrec]{D;\Psi;\Gamma \tpb d_1 : Bb \tau_1 \quad
      \dotsb \quad D;\Psi;\Gamma \tpb d_n : Bb
      \tau_n \\
      D;\Psi[bb \mapsto (Bb \tau_1, \dotsc, Bb
      \tau_n)];\Gamma |- i : \tau}{D;\Psi;\Gamma |- \iletrec{bb}{(d1,
        \dotsc, d_n)}{i} : \tau}\\\\
    \inference[Tp-call]{D(f) = \tau_1 -> \dotsc -> \tau_n -> \tau\\
    c_1 : \tau_1 \quad \dotsb \quad c_n : \tau_n}{D;\Psi;\Gamma |- \icall{f}{(c_1, \dotsc,
        c_n)} : \tau}
  \end{gather*}
  \caption{Typing 2}
  \label{fig:type-judgement-2}
\end{figure}

\begin{figure}
  \begin{gather*}
    \text{Definition Wellformedness:} \quad \boxed{D |- \Phi : D}\\\\
    \inference[Wf-defs/z]{}{D |- \cdot : \cdot}\\\\
    \inference[Wf-defs/s]{D |- \Phi' : D' \quad D;\cdot;[x_1 \mapsto
      \tau_1 \; \dotsb \; x_n \mapsto \tau_n] |- i :
      \tau \quad f \not \in D'}{D |- (f(x_1, \dotsc, x_n) = i, \Phi') : (f
      \mapsto \tau_1 -> \dotsc -> \tau_n -> \tau, D')}
  \end{gather*}
  \begin{gather*}
    \text{Program Wellformedness:} \quad \quad \boxed{|- P}\\\\
    \inference[WF-Pgm]{D |- \Phi : D \quad D;\cdot;\cdot |- i}{|- \ipgm{\Phi}{i}}
  \end{gather*}
  \caption{Typing 3}
  \label{fig:type-judgement-3}
\end{figure}

\chapter{Mini-LLVM Semantics}

\newcommand{\eop}{=>_{o}}
\begin{figure}
  \begin{gather*}
    \text{Operations:} \quad \boxed{|- op \eop n}\\
    \inference[E-Cst]{}{|- c \eop n} \quad
    \inference[E-Plus]{|- c_1 \eop n_1 \quad |- c_2 \eop n_2 \quad
      n_1 + n_2 = n}{|- c_1 + c_2 \eop n}\\\\
    \inference[E-Mone]{|- c_1 \eop n_1 \quad |- c_2 \eop n_2 \quad
      n_1 - n_2 = n}{|- c_1 - c_2 \eop n}\\\\
    \inference[E-Lt]{|- c_1 \eop n_1 \quad |- c_2 \eop n_2 \quad
      n_1 < n_2 = b}{|- c_1  < c_2 \eop b}
  \end{gather*}
  \begin{gather*}
    \text{Instructions:} \quad \boxed{\Phi;BB |- i -> i'}\\
    \inference[S-let]{|- o \eop v}{\Phi;BB |- \ilet{x}{o}{i} ->
      i[x/v]}\\\\
    \inference[S-letrec-v]{}{\Phi;BB |- \iletrec{bb}{(d_1, \dotsc,
        d_n)}{\iret{v}} -> v}\\\\
    \inference[S-letrec-s]{\Phi;BB[bb \mapsto Dt] |- i -> i'}
    {\Phi;BB |- \iletrec{bb}{Dt}{i} -> \iletrec{bb}{Dt}{i'}}\\\\
    \inference[S-brc-t]{}{\Phi;BB |-
      \ibrc{\btrue}{bb^k}{Ps}{bb^{k'}}{Ps'} -> \ibr{bb^k}{Ps}}\\\\
    \inference[S-brc-f]{}{\Phi;BB |-
      \ibrc{\bfalse}{bb^k}{Ps}{bb^{k'}}{Ps'} ->
      \ibr{bb^{k'}}{Ps'}}\\\\
    \inference[S-do-s]{\Phi;BB |- i_1 -> i'_1}{\Phi;BB |-
      \ido{x}{i_1}{i_2} -> \ido{x}{i'_1}{i_2}}\\\\
    \inference[S-do-v]{}{\Phi;BB |- \ido{x}{\iret v}{i_2} ->
      i_2[x/v]}\\\\
    \inference[S-call]{\Phi(f) = f(x_1, x_2, \dotsc, x_n)}{\Phi;BB |-
      \icall{r}{f}{(c_1, c_2, \dotsc, c_n)}{i} -> \ido{r}{f(c_1, c_2,
        \dotsc, c_n)}{i}}\\\\
    \inference[S-br]{BB(bb) = Ks \quad Ks(k) = i(x_1, \dotsc, x_n)}{\Phi;BB |- \ibr{bb^k}{(c_1, \dotsc, c_n)} ->
      i(c_1, \dotsc, c_n)}
 \end{gather*}
 \begin{gather*}
   \text{Programs:} \quad \boxed{|- P --> P'}\\
   \inference[SP]{\Phi;\cdot |- i -> i'}{\ipgm{\Phi}{i} --> \ipgm{\Phi}{i'}}
 \end{gather*}
  \caption{Semantics}
  \label{fig:semantics}
\end{figure}

\chapter{Twelf encoding}

\fixme{Describe the ``Twelf Encoding''}

\chapter{Meta-theory}

\fixme{Describe the ``Meta-theory''}

\chapter{Conclusion}

\fixme{Write the conclusion}

\bibliography{biblio}
% State what the goals of this project is.
% State we focus on the operational semantics.
% State we will use Twelf where applicable if time allows.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
