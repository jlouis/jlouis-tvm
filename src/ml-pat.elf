%% A minimalistic ML with patterns
%%  Jesper Louis Andersen, 2009.


%%%%%{ PML Type system }%%%%%

%{

Type system

}%

tp : type.

tp/nat : tp.
tp/pair : tp -> tp -> tp.
tp/arrow : tp -> tp -> tp.



%%%%%{ PML Syntax }%%%%%

%{

This very simple language have the following syntax structure

}%

pattern : tp -> type.
term : tp -> type.


pattern/s : (term T -> term T') -> pattern (tp/arrow T T').
pattern/pair : (term T ->  pattern (tp/arrow T' T''))
		-> pattern (tp/arrow (tp/pair T T') T'').



term/nat : nat -> term tp/nat.
term/plus : term tp/nat -> term tp/nat -> term tp/nat.
term/mone : term tp/nat -> term tp/nat -> term tp/nat.
term/if : term tp/nat -> term T -> term T -> term T.
term/pair : term T -> term T' -> term (tp/pair T T').
term/app : term (tp/arrow T T') -> term T -> term T'.
term/lam : (term T -> term T') -> term (tp/arrow T T').
term/let : term T -> (term T -> term T') -> term T'.
term/letrec : (term T -> term T) -> (term T -> term T') -> term T'.

plus = term/plus.
mone = term/mone.
if = term/if.
lam = term/lam.
letrec = term/letrec.
let = term/let.
app = term/app.


%%%%%{ PML Semantics }%%%%%


%{

Notion of value for PML

}%

value : term T -> type.

value/nat : value (term/nat _).

value/lam : value (term/lam _).

value/pair : value (term/pair T1 T2)
	      <- value T1
	      <- value T2.


%{

(Primitive) evaluation contexts for PML.

}%

pctx : (term T -> term T') -> type.

pctx/plus-1 : pctx ([x] term/plus x _).

pctx/plus-2 : pctx ([x] term/plus V x)
	       <- value V.

pctx/mone-1 : pctx ([x] term/mone x _).

pctx/mone-2 : pctx ([x] term/mone V x)
	       <- value V.

pctx/if-test : pctx ([x] term/if x _ _).

pctx/pair-fst : pctx ([x] term/pair x _).

pctx/pair-snd : pctx ([x] term/pair V x)
		 <- value V.

pctx/app-1 : pctx ([x] term/app x _).

pctx/app-2 : pctx ([x] term/app V x)
	      <- value V.

pctx/let : pctx ([x] term/let x _).


%{

Small-step relation for PML

}%

step : term T -> term T -> type.

step/ctx : step (EC E) (EC E')
	    <- pctx EC
	    <- step E E'.

step/plus : step (term/plus (term/nat N1) (term/nat N2)) (term/nat N3)
	     <- nat-plus N1 N2 N3. %% Values are redundant here.

step/mone : step (term/mone (term/nat N1) (term/nat N2)) (term/nat N3)
	     <- nat-mone N1 N2 N3.

step/if-false : step (term/if (term/nat z) _ E) E.

step/if-true  : step (term/if (term/nat (s _)) E _) E.

step/app-lam : step (term/app (term/lam [x] E1 x) V2) (E1 V2)
		<- value V2.


step/let-body : step (term/let V B) (B V)
		 <- value V.

step/letrec-body : step (term/letrec ([f] FB f) ([f] B f))
		    (B (FB (term/letrec ([f] FB f) ([f] f)))).


%% Iterated step relation

step-s : term T -> term T -> type.

step-s/0 : step-s T T.

step-s/s : step-s T T'
	    <- step-s T T''
	    <- step T'' T'.

%% Stepping to value.
steps-to : term T -> term T -> type.

steps-to/i : steps-to T T'
	      <- step-s T T'
	      <- value T'.

%query 1 1 (steps-to (letrec ([a] (lam [x] if x (term/nat z) (term/nat (s z))))
			([f : term (tp/arrow tp/nat tp/nat)] app f (term/nat z))) (term/nat (s z))).
%query 1 1 (steps-to (letrec ([a] (lam [x] if x (term/nat z) (term/nat (s z))))
		    ([f : term (tp/arrow tp/nat tp/nat)] app f (term/nat (s z)))) (term/nat z)).

%{

%query 1 1 (steps-to (letrec ([m] (lam [x]
				     if x (plus (term/nat (s (s z))) (app m (mone x (term/nat (s z)))))
				          (term/nat z)))
			([f] app f (term/nat (s (s (s z)))))) X).

}%