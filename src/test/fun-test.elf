%{ Small playtoy language for
   working with function calls

   TODO: There are some murky things with the Definition-blocks we ought to fix.
         Try to define the more constricted versions and see if they can be defined
         If yes, then it ought to hold.

         Define det for programs. This ought to be right.

}%

%{ ** Prelude ** }%
nat : type.

z : nat.
s : nat -> nat.

%{ ** SYNTAX ** }%

%% Function id's. These are just natural numbers
fid : type.
fid/ : nat -> type.

%% Terms
tm : type.

tm/skip : tm.
tm/semi : tm -> tm -> tm.
tm/fcall : fid -> tm.

%% Function definition lists
defs : type.

defs/z : defs.
defs/s : fid -> tm -> defs -> defs.

%% Programs
pgm : type.

pgm/ : defs -> tm -> pgm.

%{ ** Operational semantics ** }%

%% Function definition lookup.
def-lookup : defs -> fid -> tm -> type.
%mode def-lookup +D +F -T.

def-lookup/hit : def-lookup (defs/s F B _) F B.
def-lookup/miss : def-lookup (defs/s F' _ R) F Q
		   <- def-lookup R F Q.

%% Term evaluation
step : defs -> tm -> tm -> type.

step/skip : step _ (tm/semi tm/skip T) T.
step/semi : step D (tm/semi T T2) (tm/semi T' T2)
	   <- step Defs T T'.
step/fcall : step D (tm/fcall F) B
	    <- def-lookup D F B.

%% Program evaluation
step-pgm : pgm -> pgm -> type.

step-pgm/ : step-pgm (pgm/ Defs T) (pgm/ Defs T')
	   <- step Defs T T'.

%{ ** Type system ** }%

%% Helping type environment for functions
gamma : type.

gamma/z : gamma.
gamma/s : fid -> gamma -> gamma.

gamma-lookup : gamma -> fid -> type.
%mode gamma-lookup +G +F.

gamma-lookup/hit : gamma-lookup (gamma/s F _) F.
gamma-lookup/miss : gamma-lookup (gamma/s F' R) F
		     <- gamma-lookup R F.

%% Welformednesss relation. Defines when a term abides a Gamma-typing.
%%   notated as [ G |- t ]
wf : gamma -> tm -> type.
%mode wf +G +T.

wf/skip : wf _ tm/skip.
wf/semi : wf G (tm/semi T1 T2)
	   <- wf G T1
	   <- wf G T2.
wf/fcall : wf G (tm/fcall F)
	    <- gamma-lookup G F.

%% Wellformedness relation on definitions [ G |- d : G' ]
wf-def : gamma -> defs -> gamma -> type.
%mode wf-def +G +D +G'.

wf-def/z : wf-def G defs/z gamma/z.
wf-def/s : wf-def G (defs/s F T DR) (gamma/s F GR)
	    <- wf G T
	    <- wf-def G DR GR.

%% Wellformedness on programs [ |- P ]

wf-pgm : pgm -> type.

%% TODO: Perhaps we should derive Gamma explicitly. It is fairly easy.
wf-pgm/ : wf-pgm (pgm/ D T)
	   <- ({G : gamma} wf-def G D G)
	   <- ({G : gamma} wf G T).

%{ **** PROPERTIES **** }%

%{ PROGRESS }%
%% Helper. Defines when progress is good for a term.
pgood : defs -> tm -> type.

pgood/v : pgood _ tm/skip.
pgood/s : pgood D T
	   <- step D T T'.

%% Lemma, output-factored progress on fst of Semi operation
progress-tm-semi : pgood D T -> pgood D (tm/semi T T2) -> type.
%mode +{T} +{T2} +{D} +{PG : pgood D T} -{Q : pgood D (tm/semi T T2)}
      progress-tm-semi PG Q.

- : progress-tm-semi pgood/v (pgood/s step/skip).

- : progress-tm-semi (pgood/s SP) (pgood/s (step/semi SP)).

%worlds () (progress-tm-semi _ _).
%total PG (progress-tm-semi PG _).

%% Helper relating a gamma-lookup to a definition lookup if we know [ G |- d : G' ]
lookup-good : wf-def G D G' -> gamma-lookup G' F -> def-lookup D F T -> type.
%mode lookup-good +WFD +GL -DL.

- : lookup-good _ gamma-lookup/hit def-lookup/hit.

- : lookup-good (wf-def/s WFD WF) (gamma-lookup/miss GL) (def-lookup/miss DL)
     <- lookup-good WFD GL DL.

%% Lemma, progress on terms.
progress-tm : {T : tm} wf G T -> wf-def G D G -> pgood D T -> type.
%mode progress-tm +T +WF +WFD -PG.

- : progress-tm tm/skip _ _ pgood/v.

- : progress-tm (tm/semi T1 T2) (wf/semi W2 W1) WFD Q
     <- progress-tm T1 W1 WFD PG1
     <- progress-tm-semi PG1 Q.

- : progress-tm (tm/fcall F) (wf/fcall GL) WFD (pgood/s (step/fcall DL))
     <- lookup-good WFD GL DL.

%% Disjunction for progress on programs.
pgood-pgm : pgm -> type.

pgood-pgm/v : pgood-pgm (pgm/ D tm/skip).
pgood-pgm/s : pgood-pgm (pgm/ D T)
	       <- step D T T'.

%% Helper for progress on programs.
progress-pgm-h : pgood D T -> pgood-pgm (pgm/ D T) -> type.
%mode progress-pgm-h +PG -PGG.

- : progress-pgm-h pgood/v pgood-pgm/v.

- : progress-pgm-h (pgood/s SP) (pgood-pgm/s SP).

%worlds () (progress-pgm-h _ _).
%total PG (progress-pgm-h PG _).

progress : {P : pgm} wf-pgm P -> pgood-pgm P -> type.
%mode progress +P +WF -PG.

- : progress (pgm/ _ tm/skip) _ pgood-pgm/v.

- : progress (pgm/ Defs T) (wf-pgm/ WF WFD) Q
     <- ({g : gamma} progress-tm T (WF g) (WFD g) PG)
     <- progress-pgm-h PG Q.

%% Progress runs in a world where there is presence of gammas:
%block gamma-b-1 : block {g : gamma}.

%worlds (gamma-b-1) (lookup-good _ _ _).
%worlds (gamma-b-1) (progress-tm _ _ _ _).
%worlds (gamma-b-1) (progress _ _ _).
%total GL (lookup-good _ GL _).
%total T (progress-tm T _ _ _).
%total P (progress P _ _).

%{ PRESERVATION }%

preserv-lookup : def-lookup D F T -> wf-def G D G' -> wf G T -> type.
%mode preserv-lookup +DL +WFD -WF.

- : preserv-lookup def-lookup/hit (wf-def/s WFD WF) WF.

- : preserv-lookup (def-lookup/miss L) (wf-def/s WFD WF) Q
     <- preserv-lookup L WFD Q.


%% TODO:
%% Why is it [ D' |- T -> T' ] here and not [ D |- T -> T' ] ??
preserv-tm : wf G T -> wf-def G D G -> step D' T T' -> wf G T' -> type.
%mode preserv-tm +WF +WFD +SD -WF'.

- : preserv-tm (wf/semi WF2 WF1) WFD step/skip WF2.

- : preserv-tm (wf/semi WF2 WF1) WFD (step/semi T1) (wf/semi WF2 WF1')
     <- preserv-tm WF1 WFD T1 WF1'.

- : preserv-tm (wf/fcall GL) WFD (step/fcall DL) WF
     <- preserv-lookup DL WFD WF.



preservation : wf-pgm P -> step-pgm P P' -> wf-pgm P' -> type.
%mode preservation +WFP +SP -WFP'.

- : preservation (wf-pgm/ ([g] WF g) ([g] WFD g)) (step-pgm/ TSP)
%%
 (wf-pgm/ ([g] WF' g) ([g] WFD g))
%%
     <- ({g : gamma} preserv-tm (WF g) (WFD g) TSP (WF' g)).

%worlds (gamma-b-1) (preserv-lookup _ _ _).
%worlds (gamma-b-1) (preserv-tm _ _ _ _).
%worlds (gamma-b-1) (preservation _ _ _).

%total DL (preserv-lookup DL _ _).
%total WF (preserv-tm WF _ _ _).
%total S  (preservation _ S _).

%{ DETERMINISM }%

%% Helper, syntactic equality on terms and programs.
tm-eq : tm -> tm -> type.
tm-eq/ : tm-eq T T.
pgm-eq : pgm -> pgm -> type.
pgm-eq/ : pgm-eq P P.


det-tm-semi : tm-eq T T' -> tm-eq (tm/semi T T2) (tm/semi T' T2) -> type.
%mode +{T} +{T'} +{T2}
      +{EQI : tm-eq T T'} -{EQO : tm-eq (tm/semi T T2) (tm/semi T' T2)}
      det-tm-semi EQI EQO.

- : det-tm-semi tm-eq/ tm-eq/.

%worlds () (det-tm-semi _ _).
%total EQ (det-tm-semi EQ _).

%% TODO: This is definitely wrong I think.
%%   Think deeply about why it is [ D' |- T -> T' ]
%%   And                          [ D'' |- T -> T'' ]
%% It looks so damn wrong and ought to be the same D.
det-tm : wf G T -> wf-def G D G -> step D' T T' -> step D'' T T'' -> tm-eq T' T'' -> type.
%mode det-tm +WF +WFD +SP1 +SP2 -EQ.

- : det-tm _ _ step/skip step/skip tm-eq/.

- : det-tm (wf/semi WF2 WF1) WFD (step/semi SP1) (step/semi SP1') EQ
     <- det-tm WF1 WFD SP1 SP1' EQ'
     <- det-tm-semi EQ' EQ.

- : det-tm WF WFD (step/fcall DL) (step/fcall DL') tm-eq/.

%worlds () (det-tm _ _ _ _ _).
%total S (det-tm _ _ S _ _).

det : wf-pgm P -> step-pgm P P' -> step-pgm P P'' -> pgm-eq P' P'' -> type.
%mode det +WFP +SP1 +SP2 -EQ.



%{ SOUNDNESS }%

soundness : wf-pgm P -> step-pgm P P' -> pgood-pgm P' -> type.
%mode soundness +WFP +SP -PG.

- : soundness WFP SPP PGG
     <- preservation WFP SPP WFP'
     <- progress P' WFP' PGG.

%worlds () (soundness _ _ _).
%total SP (soundness _ SP _).

