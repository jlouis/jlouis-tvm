%{

The VM pre0 code is an attempt at formalizing the simple basics of a functional
VM language


TODO list:

- Query tests.
    Do a gauss-sum.
    Do an even-odd.

- Simple type system, intrinsic if possible.
    Two types at least. Try to formalize this.

}%

%{

Syntax

}%

tm : type. %name tm T.
fname : nat -> type. %name fname F.
decls : type.
defs : type.
fpar : nat -> type. %% Function parameters, carrying the number of parameters.
tm-list : nat -> type. %% List of terms, carrying the number of terms.

decls/z : defs -> decls.
decls/s : (fname K -> decls) -> decls.

defs/z : tm -> defs.
defs/s : fname K -> fpar K -> defs -> defs.

fpar/z : tm -> fpar z.
fpar/s : (tm -> fpar K) -> fpar (s K).



tm/nat : nat -> tm.
tm/plus : tm -> tm -> tm.
tm/mone : tm -> tm -> tm.
tm/ifte : tm -> tm -> tm -> tm.
tm/let : tm -> (tm -> tm) -> tm.
tm/fcall : fname K -> tm-list K -> tm.
tm/letrec : decls -> tm.

nat    = tm/nat.
plus   = tm/plus.
mone   = tm/mone.
ifte   = tm/ifte.
let    = tm/let.
fcall  = tm/fcall.
letrec = tm/letrec.



tm-list/z : tm-list z.
tm-list/s : tm -> tm-list K -> tm-list (s K).

nil = tm-list/z.
cons = tm-list/s.

%{ Static Semantics }%
value : tm -> type.

value/nat : value (tm/nat _).



value-decls : decls -> tm -> type.
value-defs  : defs -> tm -> type.

value-decls/z : value-decls (decls/z D) T
		 <- value-defs D T.

value-decls/s : value-decls (decls/s [f : fname K] D f) T
		 <- ({f : fname K} value-decls (D f) T).



value-defs/s : value-defs (defs/s _ _ D) T
		<- value-defs D T.

value-defs/z : value-defs (defs/z T) T
		<- value T.



value-list : tm-list K -> type.

value-list/z : value-list tm-list/z.

value-list/s : value-list (tm-list/s V R)
		<- value V
		<- value-list R.

%{ Small-step relation }%

%% Mapping from function names into the body of the function.
func-map : fname K -> fpar K -> type.


%% Applying a function to its parameters.
func-apply : fpar K -> tm-list K -> tm -> type.


func-apply/z : func-apply (fpar/z T) tm-list/z T.

func-apply/s : func-apply (fpar/s [x] E x) (tm-list/s T R) T'
		<- func-apply (E T) R T'.

%% Evaluation context for terms.
pctx : (tm -> tm) -> type.

pctx/plus-1 : pctx ([x] tm/plus x _).

pctx/plus-2 : pctx ([x] tm/plus V x)
	       <- value V.

pctx/mone-1 : pctx ([x] tm/mone x _).

pctx/mone-2 : pctx ([x] tm/mone V x)
	       <- value V.

pctx/ifte   : pctx ([x] tm/ifte x _ _).

pctx/let : pctx ([x] tm/let x _).





step : tm -> tm -> type.
step-tm-list : tm-list K -> tm-list K -> type.
bind-decls : decls -> decls -> type.
bind-defs : defs -> defs -> type.



bind-decls/z : bind-decls (decls/z D) (decls/z D')
	    <- bind-defs D D'.

bind-decls/s : bind-decls (decls/s [f : fname K] D f) (decls/s [f : fname K] D' f)
	    <- ({f : fname K} bind-decls (D f) (D' f)).



bind-defs/z : bind-defs (defs/z T) (defs/z T')
	       <- step T T'.

bind-defs/s : bind-defs (defs/s F T D) (defs/s F T D')
	       <- (func-map F T -> bind-defs D D').



step/pctx : step (EC E) (EC E')
	     <- pctx EC
	     <- step E E'.

step/nat : step (tm/nat N) (tm/nat N).

step/plus : step (tm/plus (tm/nat N1) (tm/nat N2)) (tm/nat N3)
	     <- nat-plus N1 N2 N3.


step/mone : step (tm/mone (tm/nat N1) (tm/nat N2)) (tm/nat N3)
	     <- nat-mone N1 N2 N3.


step/if-true : step (tm/ifte (tm/nat (s _)) E _) E.

step/if-false : step (tm/ifte (tm/nat z) _ E) E.

step/let : step (tm/let V B) (B V)
	    <- value V.

step/fcall-apply : step (tm/fcall FN VS) E
		    <- value-list VS
		    <- func-map FN B
		    <- func-apply B VS E.

step/fcall-eval : step (tm/fcall FN TS) (tm/fcall FN TS')
		   <- step-tm-list TS TS'.

step/letrec-1 : step (tm/letrec B) V
		 <- value-decls B V.

step/letrec-2 : step (tm/letrec B) (tm/letrec B')
		 <- bind-decls B B'.





step-tm-list/z : step-tm-list tm-list/z tm-list/z.

step-tm-list/s-1 : step-tm-list (tm-list/s T R) (tm-list/s T' R)
		    <- step T T'.

step-tm-list/s-2 : step-tm-list (tm-list/s V R) (tm-list/s V R')
		    <- value V
		    <- step-tm-list R R'.



%{

Query tests of the system

}%

gauss = [n] (letrec (decls/s [g : fname 1] decls/z
		      (defs/s g (fpar/s [x]
				  (fpar/z (ifte x
					     (tm/nat 0)
					     (plus
						x
						(fcall g (cons (mone x (tm/nat 1)) nil))))))
			 (defs/z (fcall g (cons n nil)))))).

even = [n] (letrec (decls/s [even : fname 1]
		       decls/s [odd  : fname 1]
			 (decls/z
			    (defs/s even (fpar/s [x]
					    (fpar/z (ifte x
						       (fcall odd (cons (mone x (tm/nat 1)) nil))
						       (tm/nat 1))))
			    (defs/s odd (fpar/s [x]
					   (fpar/z (ifte (mone x (tm/nat 1))
						      (fcall even (cons (mone x (tm/nat 1)) nil))
						      (tm/nat 0))))
			    (defs/z (fcall even (cons n nil)))))))).
