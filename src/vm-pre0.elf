%{

The VM pre0 code is an attempt at formalizing the simple basics of a functional
VM language


TODO list:

- Trace execution of the infinite loop and find the problem.
- Rewrite Decls to contain a typing relation and check it
  such that each declaration has EXACTLY one definition.

}%

%{

Syntax

}%

%{ Type system }%

tp : type. %name tp TP.

tp/nat : tp.
tp/bool : tp.

tp-list : type.

tp-list/z : tp-list. %name tp-list TPL.
tp-list/s : tp -> tp-list -> tp-list.

tp-sig : type.

tp-sig/z : tp-sig.
tp-sig/s : tp-list -> tp -> tp-sig -> tp-sig.

%{ Language syntax }%
tm : tp -> type. %name tm T.
%% Function names, with intrinsicly defined parameter and return types.
fname : tp-list -> tp -> type. %name fname F.
decls+defs : tp-sig -> tp-sig -> tp -> type. %% Type of letrec body
defs : tp-sig -> type. %% Type of letrec body.
fpar : tp-list -> tp -> type. %% Function parameters.
tm-list : tp-list -> type. %% List of terms

decls+defs/z : defs TSig -> tm T -> decls+defs tp-sig/z TSig T.
decls+defs/s : (fname TS T -> decls+defs TSig' TSig T)
		-> decls+defs (tp-sig/s TS T TSig') TSig T.

defs/z : defs tp-sig/z.
defs/s : fname TS T -> fpar TS T -> defs T' -> defs T'.

fpar/z : tm T -> fpar tp-list/z T.
fpar/s : (tm T -> fpar TS T') -> fpar (tp-list/s T TS) T'.



tm/nat : nat -> tm tp/nat.
tm/bool : nat -> tm tp/bool.
tm/plus : tm tp/nat -> tm tp/nat -> tm tp/nat.
tm/mone : tm tp/nat -> tm tp/nat -> tm tp/nat.
tm/ifte : tm tp/bool -> tm T -> tm T -> tm T.
tm/let : tm T -> (tm T -> tm T') -> tm T'.
tm/fcall : fname TS T -> tm-list TS -> tm T.
tm/letrec : decls+defs TS TS T -> tm T.
tm/isz : tm tp/nat -> tm tp/bool.

nat    = tm/nat.
plus   = tm/plus.
mone   = tm/mone.
ifte   = tm/ifte.
let    = tm/let.
fcall  = tm/fcall.
letrec = tm/letrec.
isz    = tm/isz.


true = tm/bool 1.
false = tm/bool 0.

tm-list/z : tm-list tp-list/z.
tm-list/s : tm T -> tm-list TS -> tm-list (tp-list/s T TS).

nil = tm-list/z.
cons = tm-list/s.

%{
%{ Static Semantics }%
value : tm T -> type.
%mode value +T.

value/nat : value (tm/nat _).



value-decls : decls T -> tm T -> type.
%mode value-decls +T -T'.
value-defs  : defs T -> tm T -> type.
%mode value-defs +T -T'.

value-decls/z : value-decls (decls/z D) T
		 <- value-defs D T.

value-decls/s : value-decls (decls/s [f : fname TS T] D f) T'
		 <- ({f : fname TS T} value-decls (D f) T').



value-defs/s : value-defs (defs/s _ _ D) T
		<- value-defs D T.

value-defs/z : value-defs (defs/z T) T
		<- value T.



value-list : tm-list TS -> type.
%mode value-list +TML.

value-list/z : value-list tm-list/z.

value-list/s : value-list (tm-list/s V R)
		<- value V
		<- value-list R.

%{ Small-step relation }%

%% Mapping from function names into the body of the function.
func-map : fname TS T -> fpar TS T -> type.
%mode func-map +F -FP.

%% Applying a function to its parameters.
func-apply : fpar TS T -> tm-list TS -> tm T -> type.
%mode func-apply +FP +TML -T.

func-apply/z : func-apply (fpar/z T) tm-list/z T.

func-apply/s : func-apply (fpar/s [x] E x) (tm-list/s T R) T'
		<- func-apply (E T) R T'.

%% Evaluation context for terms.
step : tm T -> tm T -> type.
%mode step +T -T'.

bind-decls : decls T -> decls T -> type.
%mode bind-decls +D -D'.
bind-defs : defs T -> defs T -> type.
%mode bind-defs +D -D'.



bind-decls/z : bind-decls (decls/z D) (decls/z D')
	    <- bind-defs D D'.

bind-decls/s : bind-decls (decls/s [f : fname TS T] D f) (decls/s [f : fname TS T] D' f)
	    <- ({f : fname TS T} bind-decls (D f) (D' f)).



bind-defs/z : bind-defs (defs/z T) (defs/z T')
	       <- step T T'.

bind-defs/s : bind-defs (defs/s F T D) (defs/s F T D')
	       <- (func-map F T -> bind-defs D D').



step/isz : step (tm/isz E) (tm/isz E')
	    <- step E E'.

step/let : step (tm/let E B) (tm/let E' B)
	    <- step E E'.

step/ifte-tst : step (tm/ifte E K1 K2) (tm/ifte E' K1 K2)
		 <- step E E'.

step/plus-1 : step (tm/plus E K) (tm/plus E' K)
	       <- step E E'.

step/plus-2 : step (tm/plus V E) (tm/plus V E')
	       <- value V
	       <- step E E'.

step/mone-1 : step (tm/mone E K) (tm/mone E' K)
	       <- step E E'.

step/mone-2 : step (tm/mone V E) (tm/mone V E')
	       <- value V
	       <- step E E'.

%%step/nat : step (tm/nat N) (tm/nat N).

step/plus : step (tm/plus (tm/nat N1) (tm/nat N2)) (tm/nat N3)
	     <- nat-plus N1 N2 N3.


step/mone : step (tm/mone (tm/nat N1) (tm/nat N2)) (tm/nat N3)
	     <- nat-mone N1 N2 N3.


step/if-true : step (tm/ifte (tm/bool (s _)) E1 E2) E1.

step/if-false : step (tm/ifte (tm/bool z) E1 E2) E2.

step/let : step (tm/let V B) (B V)
	    <- value V.

step/isz-t : step (tm/isz (tm/nat 0)) (tm/bool 1).
step/isz-f : step (tm/isz (tm/nat (s _))) (tm/bool 0).

step/fcall-apply : step (tm/fcall FN VS) E
		    <- func-map FN B
		    <- func-apply B VS E.

step/letrec-1 : step (tm/letrec B) V
		 <- value-decls B V.

step/letrec-2 : step (tm/letrec B) (tm/letrec B')
		 <- bind-decls B B'.




%{

Iterated step relations

}%

steps : tm T -> tm T -> type. %name steps Dsteps.
%mode steps +T -T'.

steps/0 : steps T T.

steps/s : steps T T''
	   <- step T T'
	   <- steps T' T''.


steps-to : tm T -> tm T -> type. %name steps-to Dsteps-to.
%mode steps-to +T -V.

steps-to/i : steps-to T V
	      <- steps T V
	      <- value V.

%{

Query tests of the system

}%


%% Test if-then-else
ifte-test1 = (ifte (tm/bool 0) (tm/nat 1) (tm/nat 2)).
ifte-test2 = (ifte (tm/bool 3) (tm/nat 1) (tm/nat 2)).

%query 1 1 (step ifte-test1 (tm/nat 2)).
%query 1 1 (step ifte-test2 (tm/nat 1)).

%% Test isz
%query 1 1 (step (isz (tm/nat 3)) false).
%query 0 1 (step (isz (tm/nat 3)) true).
%query 1 1 (step (isz (tm/nat 0)) true).
%query 0 1 (step (isz (tm/nat 0)) false).

%query 1 1 (step (mone (tm/nat 3) (tm/nat 1)) (tm/nat 2)).

letrec-test1 = letrec (decls/z (defs/z (tm/nat 0))).
letrec-test2 = letrec (decls/z (defs/z (plus (tm/nat 1) (tm/nat 2)))).
letrec-test3 = letrec (decls/s [g : fname (tp-list/s tp/nat tp-list/z) tp/nat] decls/z
			 (defs/s g (fpar/s [x]
				      (fpar/z (plus x (tm/nat 1))))
			    (defs/z (fcall g (cons (tm/nat 2) nil))))).
letrec-test4 = letrec (decls/s [g : fname (tp-list/s tp/nat tp-list/z) tp/nat] decls/z
			 (defs/s g (fpar/s [x]
				      (fpar/z (plus x (tm/nat 1))))
			    (defs/z (tm/nat 2)))).

%% 3rd test is to include something which we call.

%query 1 2 (steps-to letrec-test1 (tm/nat 0)).
%query 1 2 (steps-to letrec-test2 (tm/nat 3)).
%query 0 3 (steps-to letrec-test2 (tm/nat 0)).
%query 1 2 (steps-to letrec-test4 X).
%query 1 2 (steps-to letrec-test3 X). %% This one is wrong pt.

%{

So the problem is that the system, when calling functions is not
deterministic. There must be some rule somewhere which makes it go wrong.

Ways to attack:

- Trace.traceAll -- Look at what happens when it returns from the
  first solution.

}%

gauss = [n] (letrec (decls/s [g : fname (tp-list/s tp/nat tp-list/z) tp/nat] decls/z
		      (defs/s g (fpar/s [x]
				  (fpar/z (ifte (isz x)
					     (tm/nat 0)
					     (plus
						x
						(fcall g (cons (mone x (tm/nat 1)) nil))))))
			 (defs/z (fcall g (cons n nil)))))).

%%query 1 5 (steps-to (gauss (tm/nat 0)) X).
%%query 0 1 (steps-to (gauss (tm/nat 3)) (tm/nat 1)).

%{

even = [n] (letrec (decls/s [even : fname (tp-list/s tp/nat tp-list/z) tp/nat]
		       decls/s [odd  : fname (tp-list/s tp/nat tp-list/z) tp/nat]
			 (decls/z
			    (defs/s even (fpar/s [x]
					    (fpar/z (ifte (isz x)
						       (tm/nat 1)
						       (fcall odd (cons (mone x (tm/nat 1)) nil)))))
			    (defs/s odd (fpar/s [x]
					   (fpar/z (ifte (isz (mone x (tm/nat 1)))
						      (tm/nat 0)
						      (fcall even (cons (mone x (tm/nat 1)) nil)))))
			    (defs/z (fcall even (cons n nil)))))))).

%query 1 1 (steps-to (even (tm/nat 0)) (tm/nat 1)).
%query 1 1 (steps-to (even (tm/nat 1)) (tm/nat 0)).
%query 1 1 (steps-to (even (tm/nat 2)) (tm/nat 1)).
%query 1 1 (steps-to (even (tm/nat 3)) (tm/nat 0)).

}%
}%