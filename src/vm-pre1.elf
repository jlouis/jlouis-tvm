%{

This is version (s z) of our pre-vm version.

Jesper Louis Andersen, 2009

}%



%{

******** Type System ********

}%

%% Primitive types
tp : type.

tp/nat : tp.
tp/bool : tp.

%% Lists of primitive types
tp-list : type.

tp-list/nil : tp-list.
tp-list/cons : tp -> tp-list -> tp-list.

%% Function types
fun-tp : type.
%% There is only way to introduce a function type.
fun-tp/ : tp-list -> tp -> fun-tp.

fun-tp-list : type.
fun-tp-list/nil : fun-tp-list.
fun-tp-list/cons : fun-tp -> fun-tp-list -> fun-tp-list.

%{

******** Syntax ********

}%

%{ Introduction of function bundles.

   Function names
   Function bundles

   TODO: DOCUMENT FOR GODS SAKE!
}%

fname : fun-tp -> type.
fbundle : fun-tp-list -> type.
fbundle+ : fun-tp-list -> type.

%{ This constant only exists to appease Twelfs splitter in the input coverage }%
fbundle0 : fbundle fun-tp-list/nil.

f-hd : fbundle+ (fun-tp-list/cons FT FTL) -> fname FT.
f-tl/z : fbundle FTL -> fbundle+ FTL.
f-tl/s : fbundle+ (fun-tp-list/cons FT FTL) -> fbundle+ FTL.



tm : tp -> type.
tm-list : tp-list -> type.

tm-list/nil : tm-list tp-list/nil.
tm-list/cons : tm T -> tm-list TL -> tm-list (tp-list/cons T TL).

%{ Syntactic term equality }%
tm-eq : tm T -> tm T -> type.

tm-eq/refl : tm-eq T T.



fun-def : fun-tp -> type.

fun-def/body : tm T -> (fun-def (fun-tp/ tp-list/nil T)).
fun-def/parm : (tm T0 -> fun-def (fun-tp/ TL T)) -> fun-def (fun-tp/ (tp-list/cons T0 TL) T).

fun-def-list : fun-tp-list -> type.

fun-def-list/nil : fun-def-list fun-tp-list/nil.
fun-def-list/cons : fun-def FT -> fun-def-list FTL -> fun-def-list (fun-tp-list/cons FT FTL).

fun-list : fun-tp-list -> type.

fun-list/nil : fun-list fun-tp-list/nil.
fun-list/cons : fun-def FT -> fun-list FTL -> fun-list (fun-tp-list/cons FT FTL).


%{ Primitive constants }%
tm/cst-n : nat -> tm tp/nat.
tm/cst-b : nat -> tm tp/bool.

%{ Operations on primitive constants }%
tm/plus  : tm tp/nat -> tm tp/nat -> tm tp/nat.

%{ Control flow }%
tm/if : tm tp/bool -> tm T -> tm T -> tm T.

tm/call : fname (fun-tp/ TL T) -> tm-list TL -> tm T.
tm/letrec : (fbundle FTL -> fun-def-list FTL)
               -> (fbundle FTL -> tm T) -> tm T.


%{

******** STATIC SEMANTICS ********

}%

value : tm T -> type.


value/cst-n : value (tm/cst-n _).

value/cst-b : value (tm/cst-b _).

value-letrec : tm T -> tm T -> type.
%mode value-letrec +T -T'.

value-letrec/cst-n : value-letrec (tm/cst-n N) (tm/cst-n N).
value-letrec/cst-b : value-letrec (tm/cst-b B) (tm/cst-b B).

step : tm T -> tm T -> type.

%% Binding construct for function-bundles
fb-bind : fbundle FTL -> fun-def-list FTL -> type.
%mode fb-bind +FB -FDef.

%{ To appease Twelf splitter }%
fb-bind0 : fb-bind fbundle0 fun-def-list/nil.

fbundle-lookup : fbundle+ FTL -> fun-def-list FTL -> type.

fbundle-lookup/ctx-hit : fbundle-lookup (f-tl/z FB) FL
			  <- fb-bind FB FL.

fbundle-lookup/dig : fbundle-lookup (f-tl/s FB) R
		       <- fbundle-lookup FB (fun-def-list/cons _ R).




fun-apply : fun-def (fun-tp/ TL T) -> tm-list TL -> tm T -> type.

fun-apply/body : fun-apply (fun-def/body E) tm-list/nil E.

fun-apply/parm : fun-apply (fun-def/parm ([x] R x)) (tm-list/cons E EL) Q
		  <- fun-apply (R E) EL Q.


step/plus-1 : step (tm/plus E1 E2) (tm/plus E1' E2)
	       <- step E1 E1'.

step/plus-2 : step (tm/plus V1 E2) (tm/plus V1 E2')
	       <- value V1
	       <- step E2 E2'.

step/plus-3 : step (tm/plus (tm/cst-n N1) (tm/cst-n N2)) (tm/cst-n N3)
	       <- nat-plus N1 N2 N3.


step/if-1 : step (tm/if B T F) (tm/if B' T F)
	     <- step B B'.

step/if-f : step (tm/if (tm/cst-b z) T F) T.

step/if-t : step (tm/if (tm/cst-b (s _)) T F) F.



step/letrec-v : step (tm/letrec ([fb] Defs fb) ([fb] V)) V
		 <- value V.

step/letrec-s : step (tm/letrec ([fb] Defs fb) ([fb] Body fb))
		     (tm/letrec ([fb] Defs fb) ([fb] Body' fb))
		 <- ({fb} fb-bind fb (Defs fb) ->
		       step (Body fb) (Body' fb)).

step/call : step (tm/call (f-hd FB) EL) E
	     <- fbundle-lookup FB (fun-def-list/cons FDef _)
	     <- fun-apply FDef EL E.

%{

**** Iterated step relations ****

}%

steps : tm T -> tm T -> type.

steps/0 : steps T T.

steps/s : steps T T'
	   <- step T T''
	   <- steps T'' T'.

steps-to : tm T -> tm T -> type.

steps-to/ : steps-to T V
	     <- steps T V
	     <- value V.



%{

********* TESTS *********

}%

prg0 : tm tp/nat =
    tm/letrec ([fg] fun-def-list/cons
	      (fun-def/parm [x] fun-def/body
		 (tm/plus (tm/call (f-hd (f-tl/s (f-tl/z fg)))
			     (tm-list/cons x
				(tm-list/cons
				   (tm/cst-n 3)
				   tm-list/nil)))
		          (tm/cst-n 2)))
	      (fun-def-list/cons
		 (fun-def/parm [x] fun-def/parm [y] fun-def/body
		    (tm/plus (tm/cst-n 2)
		             (tm/call (f-hd (f-tl/z fg)) (tm-list/cons x tm-list/nil))))
		 fun-def-list/nil))
	([fg] tm/call (f-hd (f-tl/z fg)) (tm-list/cons (tm/cst-n 0) tm-list/nil)).

prg1 : tm tp/nat =
    tm/letrec ([fg] fun-def-list/cons
	            (fun-def/parm [x : tm tp/nat] fun-def/body
		       (tm/plus x
		          (tm/cst-n 2)))
	      (fun-def-list/cons
		    (fun-def/parm [x : tm tp/nat] fun-def/body
		       (tm/plus (tm/cst-n 2)
			  (tm/call (f-hd (f-tl/z fg)) (tm-list/cons x tm-list/nil))))
		 fun-def-list/nil))
	([fg] tm/call (f-hd (f-tl/s (f-tl/z fg))) (tm-list/cons (tm/cst-n 1) tm-list/nil)).

%query 1 2 (steps-to prg1 V).

%{

********* PROPERTIES *********

}%


%block det-1 : some {FTL} {Defs : fbundle FTL -> fun-def-list FTL}
	       block {fb : fbundle FTL} {fbind : fb-bind fb (Defs fb)}.

%worlds (det-1) (fbundle-lookup _ _) (fun-apply _ _ _) (fb-bind _ _).

%{

**** MAPS ****

}%
fb-bind-map : {FB : fbundle FTL} fb-bind FB Defs -> type.
%mode fb-bind-map +F -B.

%{ To appease Twelfs splitter }%
fb-bind-map0 : fb-bind-map fbundle0 fb-bind0.


fdef-eq : fun-def FT -> fun-def FT -> type.

fdef-eq/refl : fdef-eq FD FD.

fbundle-lookup-unique : fbundle-lookup FB (fun-def-list/cons FD1 _)
		     -> fbundle-lookup FB (fun-def-list/cons FD2 _) -> fdef-eq FD1 FD2 -> type.
%mode fbundle-lookup-unique +FB1 +FB2 -FDEF.

- : fbundle-lookup-unique FB1 FB2 fdef-eq/refl.


function-apply-unique : fdef-eq FD1 FD2 -> fun-apply FD1 TL E1 -> fun-apply FD2 TL E2
			 -> tm-eq E1 E2 -> type.
%mode function-apply-unique +EQ +FA1 +FA2 -TMEQ.

- : function-apply-unique fdef-eq/refl fun-apply/body fun-apply/body tm-eq/refl.

- : function-apply-unique fdef-eq/refl (fun-apply/parm FA1) (fun-apply/parm FA2) Q
     <- function-apply-unique fdef-eq/refl FA1 FA2 Q.

%{ General relation capturing the basics of type progress }%

progress-good : tm T -> type.

progress-good/value : progress-good V
		       <- value V.

progress-good/step : progress-good E
		      <- step E E'.




can-fbundle-lookup : {FB : fbundle+ (fun-tp-list/cons FT FTL)}
		      fbundle-lookup FB FDL -> type.

%mode can-fbundle-lookup +FB -FL.

- : can-fbundle-lookup (f-tl/z FB) (fbundle-lookup/ctx-hit FBBind)
     <- fb-bind-map FB FBBind.

- : can-fbundle-lookup (f-tl/s FB) (fbundle-lookup/dig Q)
     <- can-fbundle-lookup FB Q.


can-fun-apply : {EL : tm-list TL} fun-apply Parms EL T -> type.
%mode +{T : tp} +{TL : tp-list} +{Parms}
      -{E : tm T}
      +{EL : tm-list TL}
      -{FA : fun-apply Parms EL E}
      can-fun-apply EL FA.

- : can-fun-apply tm-list/nil fun-apply/body.

- : can-fun-apply (tm-list/cons E EL) (fun-apply/parm Q)
     <- can-fun-apply EL Q.

progress-plus :
%%
    progress-good E1 ->
    progress-good E2 ->
%%
    progress-good (tm/plus E1 E2) -> type.
%mode  +{E1} +{E2}
       +{PG1 : progress-good E1} +{PG2 : progress-good E2}
       -{PGG : progress-good (tm/plus E1 E2)}
       progress-plus PG1 PG2 PGG.


- : progress-plus (progress-good/step SP1) PG2 (progress-good/step (step/plus-1 SP1)).

- : progress-plus (progress-good/value VP1) (progress-good/step SP2)
     (progress-good/step (step/plus-2 SP2 VP1)).

- : progress-plus (progress-good/value VP1) (progress-good/value VP2)
       (progress-good/step (step/plus-3 CNP))
     <- can-nat-plus _ _ CNP.


progress-if : progress-good B -> progress-good (tm/if B T F) -> type.
%mode +{A : tp} +{B : tm tp/bool} +{T : tm A} +{F : tm A}
      +{PG : progress-good B}
      -{PGG : progress-good (tm/if B T F)}
      progress-if PG PGG.

- : progress-if (progress-good/step SP) (progress-good/step (step/if-1 SP)).

- : progress-if (progress-good/value VP) (progress-good/step step/if-t).

- : progress-if (progress-good/value VP) (progress-good/step step/if-f).

progress-letrec : ({F : fbundle FTL} {FB : fb-bind F (Defs F)}
		     progress-good (Body F))
		   -> progress-good (tm/letrec Defs ([fb] Body fb)) -> type.
%mode +{FTL} +{T} +{F : fbundle FTL}
      +{Body : fbundle FTL -> tm T}
      +{Defs : fbundle FTL -> fun-def-list FTL}
      +{PG : {F} {FB} progress-good (Body F)}
      -{PGG : progress-good (tm/letrec Defs Body)}
      progress-letrec PG PGG.

- : progress-letrec ([fb] [fbind] progress-good/value VP)
     (progress-good/step (step/letrec-v VP)).

- : progress-letrec ([fb] [fbind] progress-good/step (SP fb fbind))
     (progress-good/step (step/letrec-s ([fb] [fbind] SP fb fbind))).

%{

**** MAIN PROGRESS LEMMA ****

}%

progress : {E : tm T} progress-good E -> type.
%mode progress +E -PG.


-/c1 : progress (tm/cst-n _) (progress-good/value value/cst-n).

-/c2 : progress (tm/cst-b _) (progress-good/value value/cst-b).

-/plus : progress (tm/plus E1 E2) PGG
     <- progress E1 PG1
     <- progress E2 PG2
     <- progress-plus PG1 PG2 PGG.

-/if : progress (tm/if B T F) PGG
	<- progress B PGB
	<- progress-if PGB PGG.

-/lr : progress (tm/letrec (Defs : fbundle FTL -> fun-def-list FTL) Body) Q
	<- ({fb : fbundle FTL} {fbind : fb-bind fb (Defs fb)}
	      fb-bind-map fb fbind ->
	        progress (Body fb) (PG fb fbind))
	<- progress-letrec PG Q.

-/call : progress (tm/call (f-hd FB) EL)
	       (progress-good/step (step/call CFA CFL))
	  <- can-fbundle-lookup FB CFL
	  <- can-fun-apply EL CFA.

%{ Congruence on letrec }%
tm-eq-letrec-cong : ({fb} {fbind: fb-bind fb (Defs fb)} tm-eq (B1 fb) (B2 fb)) ->
		      tm-eq (tm/letrec Defs B1) (tm/letrec Defs B2) -> type.
%mode tm-eq-letrec-cong +EQ -TEQLR.

- : tm-eq-letrec-cong ([fb] [fbind] tm-eq/refl) tm-eq/refl.

%{ Congruence on constants }%
tm-eq-cst-n-cong : nat-eq N1 N2 -> tm-eq (tm/cst-n N1) (tm/cst-n N2) -> type.
%mode tm-eq-cst-n-cong +NEQ -TEQ.

- : tm-eq-cst-n-cong nat-eq/refl tm-eq/refl.


%{ Congruence on plus }%
tm-eq-plus-cong : tm-eq T1 U1 -> tm-eq T2 U2
			      -> tm-eq (tm/plus T1 T2) (tm/plus U1 U2) -> type.
%mode tm-eq-plus-cong +EQ1 +EQ2 -PEQ.

- : tm-eq-plus-cong tm-eq/refl tm-eq/refl tm-eq/refl.

%{ Congruence on if }%
tm-eq-if-cong : tm-eq B1 B2 -> tm-eq T1 T2 -> tm-eq F1 F2
		-> tm-eq (tm/if B1 T1 F1) (tm/if B2 T2 F2) -> type.
%mode tm-eq-if-cong +EQ1 +EQ2 +EQ3 -IEQ.

- : tm-eq-if-cong tm-eq/refl tm-eq/refl tm-eq/refl tm-eq/refl.


%{ Determinism of the system }%
det : step T T1 -> step T T2 -> tm-eq T1 T2 -> type.
%mode det +S1 +S2 -EQ.

- : det (step/plus-1 SP1) (step/plus-1 SP2) Q
     <- det SP1 SP2 TEQ
     <- tm-eq-plus-cong TEQ tm-eq/refl Q.

- : det (step/plus-2 SP1 VP) (step/plus-2 SP2 VP) Q
     <- det SP1 SP2 TEQ
     <- tm-eq-plus-cong tm-eq/refl TEQ Q.

- : det (step/plus-3 NP1) (step/plus-3 NP2) Q
     <- plus-unique NP1 NP2 NEQ
     <- tm-eq-cst-n-cong NEQ Q.

- : det (step/if-1 SP1) (step/if-1 SP2) Q
     <- det SP1 SP2 TEQ
     <- tm-eq-if-cong TEQ tm-eq/refl tm-eq/refl Q.

- : det step/if-t step/if-t tm-eq/refl.

- : det step/if-f step/if-f tm-eq/refl.

- : det (step/letrec-v VP) (step/letrec-v VP') tm-eq/refl.

- : det (step/letrec-s ([fb] [fbind] Run1 fb fbind))
        (step/letrec-s ([fb] [fbind] Run2 fb fbind)) Q
     <- ({fb : fbundle FTL}
	   {fbind : fb-bind fb (Defs fb)}
	   det (Run1 fb fbind) (Run2 fb fbind) (INEQ fb fbind))
     <- tm-eq-letrec-cong INEQ Q.


- : det (step/call FA1 FL1) (step/call FA2 FL2) Q
     <- fbundle-lookup-unique FL1 FL2 FBEQ
     <- function-apply-unique FBEQ FA1 FA2 Q.

%{ Blocks we need. The first one gives us the block we need in step relations }%
%block progress-1 : some {FTL : fun-tp-list} {Defs}
                    block {fb : fbundle FTL}
		          {bind : fb-bind fb (Defs fb)}
		          {map : fb-bind-map fb bind}.

%worlds (progress-1) (progress-letrec _ _) (progress-plus _ _ _)
                     (progress-if _ _)
                     (fb-bind-map _ _)
                     (progress _ _)
                     (can-fun-apply _ _) (can-fbundle-lookup _ _).

%worlds (det-1) (tm-eq-cst-n-cong _ _)
                (tm-eq-plus-cong _ _ _) (tm-eq-letrec-cong _ _)
                (tm-eq-if-cong _ _ _ _) (fbundle-lookup-unique _ _ _)
                (function-apply-unique _ _ _ _).

%worlds (det-1) (det _ _ _).

%{ Various obvious uniqueness lemmas }%
%unique fun-apply +FD +TL -1T.
%unique fb-bind +F -1B.
%unique fbundle-lookup +FB -1FDef.

%{ Progress totality }%
%total N (progress-plus N _ _).
%total E (can-fun-apply E _).
%total PG (progress-letrec PG _).
%total PG (progress-if PG _).
%total E (fb-bind-map E _).
%total (T N) (can-fbundle-lookup N _) (progress T _).

%{ Determinism totality }%

%total FB (fbundle-lookup-unique FB _ _).
%total FB (function-apply-unique _ FB _ _).
%total FB (tm-eq-letrec-cong FB _).
%{ TODO: Fix the %thaw we use. Should be fairly easy }%
%total T (tm-eq-cst-n-cong T _).
%total T (tm-eq-if-cong T _ _ _).
%total T (tm-eq-plus-cong T _ _).
%total S (det S _ _).


