%{

This is version (s z) of our pre-vm version.

Jesper Louis Andersen, 2009

}%



%{

******** Type System ********

}%

%% Primitive types
tp : type.

tp/nat : tp.
tp/bool : tp.

%% Lists of primitive types
tp-list : type.

tp-list/nil : tp-list.
tp-list/cons : tp -> tp-list -> tp-list.

%% Function types
fun-tp : type.
%% There is only way to introduce a function type.
fun-tp/ : tp-list -> tp -> fun-tp.

fun-tp-list : type.
fun-tp-list/nil : fun-tp-list.
fun-tp-list/cons : fun-tp -> fun-tp-list -> fun-tp-list.

%{

******** Syntax ********

}%

%{ Introduction of function bundles.

   Function names
   Function bundles

   TODO: DOCUMENT FOR GODS SAKE!
}%

fname : fun-tp -> type.
fbundle : fun-tp-list -> type.

f-hd : fbundle (fun-tp-list/cons FT FTL) -> fname FT.
f-tl : fbundle (fun-tp-list/cons FT FTL) -> fbundle FTL.



tm : tp -> type.
tm-list : tp-list -> type.

tm-list/nil : tm-list tp-list/nil.
tm-list/cons : tm T -> tm-list TL -> tm-list (tp-list/cons T TL).


fun-def : fun-tp -> type.

fun-def/body : tm T -> (fun-def (fun-tp/ tp-list/nil T)).
fun-def/parm : (tm T0 -> fun-def (fun-tp/ TL T)) -> fun-def (fun-tp/ (tp-list/cons T0 TL) T).

fun-def-list : fun-tp-list -> type.

fun-def-list/nil : fun-def-list fun-tp-list/nil.
fun-def-list/cons : fun-def FT -> fun-def-list FTL -> fun-def-list (fun-tp-list/cons FT FTL).

fun-list : fun-tp-list -> type.

fun-list/nil : fun-list fun-tp-list/nil.
fun-list/cons : fun-def FT -> fun-list FTL -> fun-list (fun-tp-list/cons FT FTL).


%{ Primitive constants }%
tm/cst-n : nat -> tm tp/nat.
tm/cst-b : nat -> tm tp/bool.
tm/plus  : tm tp/nat -> tm tp/nat -> tm tp/nat.


tm/call : fname (fun-tp/ TL T) -> tm-list TL -> tm T.
tm/letrec : (fbundle FTL -> fun-def-list FTL)
               -> (fbundle FTL -> tm T) -> tm T.


%{ Equality on terms. Syntactical equal terms are equal }%
tm-eq : tm T -> tm T -> type.

tm-eq/refl : tm-eq E E.

%{

******** STATIC SEMANTICS ********

}%

value : tm T -> type.


value/cst-n : value (tm/cst-n _).

value/cst-b : value (tm/cst-b _).

value-letrec : tm T -> tm T -> type.
%mode value-letrec +T -T'.

value-letrec/cst-n : value-letrec (tm/cst-n N) (tm/cst-n N).
value-letrec/cst-b : value-letrec (tm/cst-b B) (tm/cst-b B).

step : tm T -> tm T -> type.

%% Binding construct for function-bundles
fb-bind : fbundle FTL -> fun-def-list FTL -> type.
%mode fb-bind +FB -FDef.

fbundle-lookup : fname FT -> fun-def-list (fun-tp-list/cons FT _) -> type.

fbundle-lookup/ctx-hit : fbundle-lookup (f-hd FB) FL
			  <- fb-bind FB FL.

fbundle-lookup/miss : fbundle-lookup (f-hd (f-tl FB)) R
		       <- fbundle-lookup (f-hd FB) (fun-def-list/cons _ R).


fun-apply : fun-def (fun-tp/ TL T) -> tm-list TL -> tm T -> type.

step/plus-1 : step (tm/plus E1 E2) (tm/plus E1' E2)
	       <- step E1 E1'.

step/plus-2 : step (tm/plus V1 E2) (tm/plus V1 E2')
	       <- value V1
	       <- step E2 E2'.

step/plus-3 : step (tm/plus (tm/cst-n N1) (tm/cst-n N2)) (tm/cst-n N3)
	       <- nat-plus N1 N2 N3.

step/letrec-v : step (tm/letrec ([fb] Defs fb) ([fb] Body fb)) V
		 <- ({fb} fb-bind fb (Defs fb) ->
			  value (Body fb))
		 <- ({fb} fb-bind fb (Defs fb) ->
			  tm-eq (Body fb) V).

step/letrec-s : step (tm/letrec ([fb] Defs fb) ([fb] Body fb)) E
		 <- ({fb} fb-bind fb (Defs fb) ->
		       step (Body fb) E).

step/call : step (tm/call FN EL) E
	     <- fbundle-lookup FN (fun-def-list/cons FDef _)
	     <- fun-apply FDef EL E.


%{

********* PROPERTIES *********

}%

%{ General realtion capturing the basics of type progress }%

progress-good : tm T -> type.

progress-good/value : progress-good V
		       <- value V.

progress-good/step : progress-good E
		      <- step E E'.


%{ Lemma capturing Plus }%
fb-bind-map : {FB : fbundle FTL} fb-bind FB Defs -> type.
%mode +{FTL} +{D : fun-def-list FTL} +{F : fbundle FTL}
      -{B : fb-bind F D}
      fb-bind-map F B.

%worlds () (fb-bind-map _ _).
%%total F (fb-bind-map F _).

progress-plus :
%%
    progress-good E1 ->
    progress-good E2 ->
%%
    progress-good (tm/plus E1 E2) -> type.
%mode  +{E1} +{E2}
       +{PG1 : progress-good E1} +{PG2 : progress-good E2}
       -{PGG : progress-good (tm/plus E1 E2)}
       progress-plus PG1 PG2 PGG.


- : progress-plus (progress-good/step SP1) PG2 (progress-good/step (step/plus-1 SP1)).

- : progress-plus (progress-good/value VP1) (progress-good/step SP2)
     (progress-good/step (step/plus-2 SP2 VP1)).

- : progress-plus (progress-good/value VP1) (progress-good/value VP2)
       (progress-good/step (step/plus-3 CNP))
     <- can-nat-plus _ _ CNP.

progress-letrec : {Defs} ({F} progress-good (Body F))
		   -> progress-good (tm/letrec Defs Body) -> type.
%mode progress-letrec +Defs +PG -PGG.



%{

**** MAIN PROGRESS LEMMA ****

}%

progress : {E : tm T} progress-good E -> type.
%mode progress +E -PG.


-/c1 : progress (tm/cst-n _) (progress-good/value value/cst-n).

-/c2 : progress (tm/cst-b _) (progress-good/value value/cst-b).

-/p : progress (tm/plus E1 E2) PGG
     <- progress E1 PG1
     <- progress E2 PG2
     <- progress-plus PG1 PG2 PGG.

-/lrv : progress (tm/letrec Defs Body) Q
     <- ({fb : fbundle FTL} {fbind : fb-bind fb (D fb)}
	   {fbmap : fb-bind-map fb fbind}
	   progress (Body fb) (PG fb))
     <- ({fb : fbundle FTL} {fbind : fb-bind fb (D fb)}
	   {fbmap : fb-bind-map fb fbind}
	   progress-letrec Defs PG Q).

%{

The tm/call holds because of 2 effectiveness lemmas: can-lookup-fbundle
and can-apply-function. I've thought about those and they look simple.

}%

%block progress-1 : some {FTL} {Defs : fbundle FTL -> fun-def-list FTL}
                    block {fb : fbundle FTL}
		          {fb_bind : fb-bind fb (Defs fb)}
                          {fbundle_map : fb-bind-map fb fb_bind}.

%worlds (progress-1) (progress-letrec _ _ _).

%worlds (progress-1) (progress-plus _ _ _).
%total N (progress-plus N _ _).

%worlds (progress-1) (progress _ _).

%%worlds () (progress _ _).
%%total E (progress E _).

