%{

********* PROPERTIES *********

}%


%block det-1 : some {FTL} {Defs : pbundle FTL -> bb-def-list FTL}
	       block {pb : pbundle FTL} {bbind : bb-bind pb (Defs pb)}.

%worlds (det-1) (pbundle-lookup _ _) (bb-apply _ _ _) (bb-bind _ _).

%{

**** MAPS ****

}%

pb-bind-map : {PB : pbundle FTL} bb-bind PB Defs -> type.
%mode pb-bind-map +F -B.

%{ To appease Twelfs splitter }%
fb-bind-map0 : pb-bind-map pbundle0 bb-bind0.


bb-def-eq : bb-def FT -> bb-def FT -> type.

bb-def-eq/refl : bb-def-eq FD FD.

pbundle-lookup-unique : pbundle-lookup FB (bb-def-list/cons FD1 _)
		     -> pbundle-lookup FB (bb-def-list/cons FD2 _) -> bb-def-eq FD1 FD2 -> type.
%mode pbundle-lookup-unique +FB1 +FB2 -FDEF.

- : pbundle-lookup-unique FB1 FB2 bb-def-eq/refl.

insn-eq : insn T -> insn T -> type.

insn-eq/ : insn-eq I I.


function-apply-unique : bb-def-eq FD1 FD2 -> bb-apply FD1 TL E1 -> bb-apply FD2 TL E2
			 -> insn-eq E1 E2 -> type.
%mode function-apply-unique +EQ +FA1 +FA2 -TMEQ.

- : function-apply-unique bb-def-eq/refl bb-apply/body bb-apply/body insn-eq/.

- : function-apply-unique bb-def-eq/refl (bb-apply/phi FA1) (bb-apply/phi FA2) Q
     <- function-apply-unique bb-def-eq/refl FA1 FA2 Q.

%{ General relation capturing the basics of type progress }%

progress-good : insn T -> type.

progress-good/value : progress-good V
		       <- value V.

progress-good/step : progress-good E
		      <- step E E'.




can-pbundle-lookup : {FB : pbundle+ (bb-tp-list/cons FT FTL)}
		      pbundle-lookup FB FDL -> type.
%mode can-pbundle-lookup +FB -FL.

- : can-pbundle-lookup (f-tl/z FB) (pbundle-lookup/ctx-hit FBBind)
     <- pb-bind-map FB FBBind.

- : can-pbundle-lookup (f-tl/s FB) (pbundle-lookup/dig Q)
     <- can-pbundle-lookup FB Q.


can-bb-apply : {RL : reg-list TL} bb-apply Parms RL T -> type.
%mode +{T : tp} +{TL : tp-list} +{Parms}
      -{E : insn T}
      +{RL : reg-list TL}
      -{FA : bb-apply Parms RL E}
      can-bb-apply RL FA.

- : can-bb-apply reg-list/nil bb-apply/body.

- : can-bb-apply (reg-list/cons E EL) (bb-apply/phi Q)
     <- can-bb-apply EL Q.

%{
progress-if : progress-good B -> progress-good (tm/if B T F) -> type.
%mode +{A : tp} +{B : tm tp/bool} +{T : tm A} +{F : tm A}
      +{PG : progress-good B}
      -{PGG : progress-good (tm/if B T F)}
      progress-if PG PGG.

- : progress-if (progress-good/step SP) (progress-good/step (step/if-1 SP)).

- : progress-if (progress-good/value VP) (progress-good/step step/if-t).

- : progress-if (progress-good/value VP) (progress-good/step step/if-f).
}%


%{
progress-let : progress-good T -> progress-good (insn/let T B) -> type.
%mode +{A : tp} +{B : tp} +{T : tm A} +{Bdy : reg A -> tm B}
      +{TG : progress-good T}
      -{BG : progress-good (tm/let T Bdy)}
      progress-let TG BG.

- : progress-let (progress-good/value VP) (progress-good/step (step/let-a VP)).

- : progress-let (progress-good/step SP) (progress-good/step (step/let-s SP)).
}%

progress-letrec : ({F : pbundle FTL} {FB : bb-bind F (Defs F)}
		     progress-good (Body F))
		   -> progress-good (insn/letrec Defs ([fb] Body fb)) -> type.
%mode +{FTL} +{T} +{F : pbundle FTL}
      +{Body : pbundle FTL -> insn T}
      +{Defs : pbundle FTL -> bb-def-list FTL}
      +{PG : {F} {FB} progress-good (Body F)}
      -{PGG : progress-good (insn/letrec Defs Body)}
      progress-letrec PG PGG.

- : progress-letrec ([fb] [fbind] progress-good/value VP)
     (progress-good/step (step/letrec-v VP)).

- : progress-letrec ([fb] [fbind] progress-good/step (SP fb fbind))
     (progress-good/step (step/letrec-s ([fb] [fbind] SP fb fbind))).

progress-do : progress-good I1 -> progress-good (insn/do I1 B) -> type.
%mode +{T} +{T'}
      +{I1 : insn T'} +{B : (reg T' -> insn T)} +{PG : progress-good I1}
      -{PGG : progress-good (insn/do I1 B)}
      progress-do PG PGG.

- : progress-do (progress-good/value VP) (progress-good/step step/do-v).

- : progress-do (progress-good/step SP) (progress-good/step (step/do-s SP)).

%{

**** MAIN PROGRESS LEMMA ****

}%

progress : {E : insn T} progress-good E -> type.
%mode progress +E -PG.


-/return : progress (insn/return _) (progress-good/value value/return).

-/lr : progress (insn/letrec (Defs : pbundle FTL -> bb-def-list FTL) Body) Q
	<- ({fb : pbundle FTL} {fbind : bb-bind fb (Defs fb)}
	      pb-bind-map fb fbind ->
	        progress (Body fb) (PG fb fbind))
	<- progress-letrec PG Q.

-/br : progress (insn/br (f-hd FB) EL)
	    (progress-good/step (step/br CFA CFL))
	<- can-pbundle-lookup FB CFL
	<- can-bb-apply EL CFA.

-/brc-t : progress (insn/brc (reg/cst-b (s _)) _ _ _ _)
	   (progress-good/step step/brc-t).

-/brc-f : progress (insn/brc (reg/cst-b z) L1 R1 L2 R2)
	   (progress-good/step step/brc-f).

%{
-/do-s : progress (insn/do T1 B) Q
	  <- progress T1 PG
	  <- progress-do PG Q.
}%

%{
-/let : progress (insn/let T B) Q
	 <- progress T PG
	 <- progress-let PG Q.
-/plus : progress (tm/plus (reg/cst-n N1) (reg/cst-n N2))
	     (progress-good/step (step/plus CNP))
	  <- can-nat-plus N1 N2 CNP.
-/if-t : progress (tm/if (reg/cst-b z) T F) (progress-good/step step/if-f).

-/if-f : progress (tm/if (reg/cst-b (s _)) T F) (progress-good/step step/if-t).
}%

%{ Congruence on letrec }%
insn-eq-letrec-cong : ({fb} {fbind: bb-bind fb (Defs fb)} insn-eq (B1 fb) (B2 fb)) ->
		      insn-eq (insn/letrec Defs B1) (insn/letrec Defs B2) -> type.
%mode insn-eq-letrec-cong +EQ -TEQLR.

- : insn-eq-letrec-cong ([fb] [fbind] insn-eq/) insn-eq/.


%{
insn-eq-let-cong : insn-eq T1 T2
	       -> insn-eq (insn/let T1 B) (insn/let T2 B) -> type.
%mode +{A : tp} +{B : tp} +{T1 : tm A} +{T2 : tm A} +{B : reg A -> tm B}
      +{EQ1 : insn-eq T1 T2}
      -{LEQ : insn-eq (tm/let T1 B) (tm/let T2 B)}
      insn-eq-let-cong EQ1 LEQ.

- : insn-eq-let-cong insn-eq/refl insn-eq/refl.
}%


%{ Determinism of the system }%
det : step T T1 -> step T T2 -> insn-eq T1 T2 -> type.
%mode det +S1 +S2 -EQ.

%{
- : det (step/plus SP1) (step/plus SP2) insn-eq/refl.

- : det step/if-t step/if-t insn-eq/refl.

- : det step/if-f step/if-f insn-eq/refl.

- : det (step/let-a VP) (step/let-a VP1) insn-eq/refl.

- : det (step/let-s SP) (step/let-s SP1) Q
     <- det SP SP1 TEQ
     <- insn-eq-let-cong TEQ Q.

- : det (step/letrec-v VP) (step/letrec-v VP') insn-eq/refl.

- : det (step/letrec-s ([fb] [fbind] Run1 fb fbind))
        (step/letrec-s ([fb] [fbind] Run2 fb fbind)) Q
     <- ({fb : pbundle FTL}
	   {fbind : fb-bind fb (Defs fb)}
	   det (Run1 fb fbind) (Run2 fb fbind) (INEQ fb fbind))
     <- insn-eq-letrec-cong INEQ Q.


- : det (step/call FA1 FL1) (step/call FA2 FL2) Q
     <- pbundle-lookup-unique FL1 FL2 FBEQ
     <- function-apply-unique FBEQ FA1 FA2 Q.
}%


%{ Blocks we need. The first one gives us the block we need in step relations }%
%block progress-1 : some {FTL : bb-tp-list} {Defs}
                    block {fb : pbundle FTL}
		          {bind : bb-bind fb (Defs fb)}
		          {map : pb-bind-map fb bind}.

%worlds (progress-1) (progress-letrec _ _)
                     (progress-do _ _)
                     (pb-bind-map _ _)
                     (progress _ _)
                     (can-bb-apply _ _) (can-pbundle-lookup _ _).

%worlds (det-1) (insn-eq-letrec-cong _ _)
                (pbundle-lookup-unique _ _ _)
                (function-apply-unique _ _ _ _).

%worlds (det-1) (det _ _ _).

%{ Various obvious uniqueness lemmas }%
%unique bb-apply +FD +TL -1T.
%unique bb-bind +F -1B.
%unique pbundle-lookup +FB -1FDef.


%{ Progress totality }%
%total E (can-bb-apply E _).
%total PG (progress-letrec PG _).
%total T  (progress-do T _).
%%total PG (progress-let PG _).
%total E (pb-bind-map E _).
%total (T N) (can-pbundle-lookup N _) (progress T _).

%{
%total (T N) (can-pbundle-lookup N _) (progress T _).


%{ Determinism totality }%
%total FB (pbundle-lookup-unique FB _ _).
%total FB (function-apply-unique _ FB _ _).
%total T (insn-eq-let-cong T _).
%total FB (insn-eq-letrec-cong FB _).
%total S (det S _ _).


}%