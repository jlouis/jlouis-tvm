%% Definition of a LLVM-inspired Virtual Machine language
%% Jesper Louis Andersen, 2009.





%%%%%{ Maps and label identifiers }%%%%%



%{

We define some mappings so we can store things in the context. We hope
this will make the development easier later on.

We need:

A mapping from labels into basic blocks.

>>> NOTE
Perhaps we need more, but this is a start.
<<<

A 'bb' designates a basic block. We will define their contents later on.

}%

bb-map : label -> bb -> type.




%%%%%{ Expression Semantics }%%%%%

%{

I have decided on using small-step semantics rather than a big-step
semantics. This choice is made somewhat haphazardly on the gut
intuition that it will beneficial to have fine-grained control over
what happens.

Other parts of this development is actually big-step in its notion.
Particular function-applications.


}%

exp-step : exp -> reg -> type.

exp-step/constant : exp-step (exp/constant R) R.

exp-step/plus : exp-step (exp/plus (reg/constant N1)
			           (reg/constant N2))
%%
		                   (reg/constant N3)
		 <- nat-plus N1 N2 N3.

exp-step/lt-true : exp-step (exp/lt (reg/constant N1) (reg/constant N2)) (reg/constant 1)
		    <- nat-lt N1 N2 true.

exp-step/lt-false : exp-step (exp/lt (reg/constant N1) (reg/constant N2)) (reg/constant 0)
		     <- nat-lt N1 N2 false.







%%%%%{ Instruction Semantics }%%%%%



%{

Evaluation of Instructions utilizes beta-reduction. As soon as we know
the value of a definition, we replace it into all uses by
substitution.

Again, we use a simple stepping relation, small-step style.

Finally, the bb-apply relation is defined here so we can refer to it in
the step/br(c) case, but we will handle it in the Basic Block Semantics section.
The idea of bb-apply is to apply a list of registers to a basic block, effectively
handling the phi-nodes in the basic block.

}%

bb-apply : reg-list -> bb-header -> instruction -> type.



instruction-step : instruction -> instruction -> type.

instruction-step/let : instruction-step (instruction/let E ([x] I x)) (I E')
			<- exp-step E E'.

instruction-step/return : instruction-step (instruction/return R) (instruction/return R).

instruction-step/br : instruction-step (instruction/br L EL) IS
		       <- bb-map L (bb/def _ BBH)
		       <- bb-apply EL BBH IS.

instruction-step/brc-t : instruction-step (instruction/brc (reg/constant 1) L EL _ _) IS
			  <- bb-map L (bb/def _ BBH)
			  <- bb-apply EL BBH IS.

instruction-step/brc-f : instruction-step (instruction/brc (reg/constant 0) _ _ L EL) IS
			  <- bb-map L (bb/def _ BBH)
			  <- bb-apply EL BBH IS.




%{

Iterated step relations. 'instruction-steps' will step a series of 0 or more steps.
'instruction-steps-to' will step until we reach something which is a value.

}%

instruction-steps : instruction -> instruction -> type.

instruction-steps/0 : instruction-steps I I.

instruction-steps/s : instruction-steps I I'
		       <- instruction-step I I''
		       <- instruction-steps I'' I'.





instruction-steps-to : instruction -> instruction -> type.

instruction-steps-to/do : instruction-steps-to I I'
			   <- instruction-steps I I'
			   <- instruction-value I'.






%%%%%{ Basic Block Semantics }%%%%%

%{

The following applies a list of expressions to a basic-block header, effectively
executing the basic block by substituting the values into the block and replacing
current (small-step) execution context with the contents of the BB body.

}%

bb-apply/nil : bb-apply reg-list/nil (bb-header/body I) I.

bb-apply/cons : bb-apply (reg-list/cons REG RL) (bb-header/phi ([x] PHI x)) I
		 <- bb-apply RL (PHI REG) I.









%%%%%{ Function Semantics }%%%%%

%{

Currently, we use some very crippled function semantics. We just tell
how a function body should be executed. The plan is to wrap this
knowledge later on with the notion of real functions. The ideas are in
the code however on how to handle this easily.

Function body execution amount to shuffling basic blocks into the
context so we can refer them later when needed under BB execution.

}%


%% Helper function for function-body-apply.
function-body-app : reg-list -> label -> bb-list -> instruction -> type.

function-body-app/nil : function-body-app REGS L bb-list/nil V
			  <- bb-map L (bb/def _ BBH)
			  <- bb-apply REGS BBH IS
			  <- instruction-steps-to IS V.

function-body-app/cons : function-body-app REGS L (bb-list/cons L' BB REST) Q
			   <- (bb-map L' BB -> function-body-app REGS L REST Q).




function-body-apply : reg-list -> function-body -> instruction -> type.

function-body-apply/do : function-body-apply REGS (function-body/def L BBL) I
			  <- function-body-app REGS L BBL I.



