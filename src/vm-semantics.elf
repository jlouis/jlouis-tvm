%{

This is version (s z) of Mini-LLVM.

Jesper Louis Andersen, 2009

}%

%{

******** STATIC SEMANTICS ********

}%

value : insn T -> type.

value/ret : value (insn/return _).



%{

******** DYNAMIC SEMANTICS *******

}%

bb-bind : pbundle FTL -> bb-def-list FTL -> type.
%mode bb-bind +PB -BBDef.

%{ This is to work around a bug in Twelfs splitter }%
bb-bind0 : bb-bind pbundle0 bb-def-list/nil.

%{ When referring to an internal bb, ie a phi node, we use this
   relation to look up the relevant bb in the phi-bundle }%
pbundle-lookup : pbundle+ FTL -> bb-def-list FTL -> type.

pbundle-lookup/ctx-hit : pbundle-lookup (f-tl/z PB) FL
			  <- bb-bind PB FL.

pbundle-lookup/dig     : pbundle-lookup (f-tl/s PB) R
			  <- pbundle-lookup PB (bb-def-list/cons _ R).

bb-apply : bb-def (bb-tp/ TL T) -> reg-list TL -> insn T -> type.

bb-apply/body : bb-apply (bb-def/body E) reg-list/nil E.

bb-apply/phi  : bb-apply (bb-def/phi ([x] R x)) (reg-list/cons E EL) Q
		 <- bb-apply (R E) EL Q.

function-lookup : fun-id R TL -> fun-decl R TL -> type.


function-apply : fun-decl R TL -> reg-list TL -> insn R -> type.

function-apply/body : function-apply (fun-decl/body B) reg-list/nil B.

function-apply/parm : function-apply (fun-decl/parm [r] FD r)
		                     (reg-list/cons R RL) Q
		       <- function-apply (FD R) RL Q.



step-op : op T -> reg T -> type.

step-op/plus : step-op (op/plus (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-n N3)
		<- nat-plus N1 N2 N3.

step-op/cmp-lt : step-op (op/cmp-lt (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-b B)
		  <- nat-lt N1 N2 B.

step : insn T -> insn T -> type.

step/let : step (insn/let T B) (B V)
	    <- step-op T V.

step/letrec-v : step (insn/letrec ([pb] Defs pb) ([pb] V)) V
		 <- value V.

step/letrec-s : step (insn/letrec ([pb] Defs pb) ([pb] Body pb))
                     (insn/letrec ([pb] Defs pb) ([pb] Body' pb))
		 <- ({pb} bb-bind pb (Defs pb) ->
		         step (Body pb) (Body' pb)).

step/brc-t : step (insn/brc (reg/cst-b (s _)) L RL _ _) (insn/br L RL).

step/brc-f : step (insn/brc (reg/cst-b z) _ _ L RL) (insn/br L RL).

step/do-s : step (insn/do T B) (insn/do T' B)
	   <- step T T'.

step/do-v : step (insn/do (insn/return R) B) (B R).

step/br : step (insn/br (f-hd PB) RL) E
	   <- pbundle-lookup PB (bb-def-list/cons BBDef _)
	   <- bb-apply BBDef RL E.

step/call : step (insn/call Fid RL ([r] Body r))
	         (insn/do T ([r] Body r))
	     <- function-lookup Fid FDecl
	     <- function-apply FDecl RL T.

%{

**** Iterated step relations ****

}%

steps : insn T -> insn T -> type.

steps/0 : steps T T.

steps/s : steps T T'
	   <- step T T''
	   <- steps T'' T'.

steps-to : insn T -> insn T -> type.

steps-to/ : steps-to T V
	     <- steps T V
	     <- value V.


eval-program : fun-list -> reg T -> type.

eval-program/main : eval-program (fun-list/main Fid) R
		     <- function-lookup Fid FDecl
		     <- function-apply FDecl reg-list/nil IS
		     <- steps-to IS (insn/return R).

eval-program/cons : eval-program (fun-list/cons Fid FDecl Rest) Q
		     <- (function-lookup Fid FDecl ->
			   eval-program Rest Q).

