%{

This is version (s z) of Mini-LLVM.

Jesper Louis Andersen, 2009

}%

%{

******** STATIC SEMANTICS ********

}%

value : insn T -> type.

value/ret : value (insn/return _).



%{

******** DYNAMIC SEMANTICS *******

}%

bb-bind : pbundle FTL -> bb-def-list FTL -> type.
%mode bb-bind +PB -BBDef.

def-bind : defs -> type.
%mode def-bind +D.

%{ This is to work around a bug in Twelfs splitter }%
bb-bind0 : bb-bind pbundle0 bb-def-list/nil.

%{ When referring to an internal bb, ie a phi node, we use this
   relation to look up the relevant bb in the phi-bundle }%
pbundle-lookup : pbundle+ FTL -> bb-def-list FTL -> type.

pbundle-lookup/ctx-hit : pbundle-lookup (f-tl/z PB) FL
			  <- bb-bind PB FL.

pbundle-lookup/dig     : pbundle-lookup (f-tl/s PB) R
			  <- pbundle-lookup PB (bb-def-list/cons _ R).

bb-apply : bb-def (bb-tp/ TL T) -> reg-list TL -> insn T -> type.

bb-apply/body : bb-apply (bb-def/body E) reg-list/nil E.

bb-apply/phi  : bb-apply (bb-def/phi ([x] R x)) (reg-list/cons E EL) Q
		 <- bb-apply (R E) EL Q.

%% This needs a definition
function-lookup : fun-id R TL -> defs -> fun-decl -> type.

function-lookup/hit : function-lookup (fun-id/ N) (defs/s (fid/ N) FD R) FD.

function-lookup/miss : function-lookup (fun-id/ N) (defs/s (fid/ N') _ R) Q
			<- function-lookup (fun-id/ N) R Q.



function-apply : fun-decl -> reg-list TL -> insn R -> type.

function-apply/body : function-apply (fun-decl/body BB) reg-list/nil BB.

function-apply/parm : function-apply (fun-decl/parm [r] FD r)
		                     (reg-list/cons R RL) Q
		       <- function-apply (FD R) RL Q.



step-op : op T -> reg T -> type.

step-op/plus : step-op (op/plus (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-n N3)
		<- nat-plus N1 N2 N3.
step-op/mone : step-op (op/mone (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-n N3)
		<- nat-mone N1 N2 N3.

step-op/cmp-lt : step-op (op/cmp-lt (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-b B)
		  <- nat-lt N1 N2 B.

step : insn T -> insn T -> type.

step/let : step (insn/let T B) (B V)
	    <- step-op T V.

step/letrec-v : step (insn/letrec ([pb] Defs pb) ([pb] V)) V
		 <- value V.

step/letrec-s : step (insn/letrec ([pb] Defs pb) ([pb] Body pb))
                     (insn/letrec ([pb] Defs pb) ([pb] Body' pb))
		 <- ({pb} bb-bind pb (Defs pb) ->
		         step (Body pb) (Body' pb)).

step/brc-t : step (insn/brc (reg/cst-b (s _)) L RL _ _) (insn/br L RL).

step/brc-f : step (insn/brc (reg/cst-b z) _ _ L RL) (insn/br L RL).

step/do-s : step (insn/do T B) (insn/do T' B)
	   <- step T T'.

step/do-v : step (insn/do (insn/return R) B) (B R).

step/br : step (insn/br (f-hd PB) RL) E
	   <- pbundle-lookup PB (bb-def-list/cons BBDef _)
	   <- bb-apply BBDef RL E.

step/call : step (insn/call Fid RL ([r] Body r))
	         (insn/do T ([r] Body r))
	     <- def-bind Defs
	     <- function-lookup Fid Defs FDecl
	     <- function-apply FDecl RL T.


step-pgm : pgm -> pgm -> type.

step-pgm/ : step-pgm (pgm/ D T) (pgm/ D T')
	     <- (def-bind D -> step T T').

%{

**** Iterated step relations ****

}%

steps : pgm -> pgm -> type.

steps/0 : steps P P.

steps/s : steps P P'
	   <- step-pgm P P''
	   <- steps P'' P'.

steps-to : pgm -> pgm -> type.

steps-to/ : steps-to (pgm/ D T) (pgm/ D V)
	     <- steps (pgm/ D T) (pgm/ D V)
	     <- value V.


