%{

This is version (s z) of Mini-LLVM.

Jesper Louis Andersen, 2009

}%

%{

******** STATIC SEMANTICS ********

}%

value : insn T -> type.

value/ret : value (insn/return _).



%{

******** DYNAMIC SEMANTICS *******

}%

bb-bind : pbundle FTL -> bb-def-list FTL -> type.
%mode bb-bind +PB -BBDef.

%{ This is to work around a bug in Twelfs splitter }%
bb-bind0 : bb-bind pbundle0 bb-def-list/nil.

%{ When referring to an internal bb, ie a phi node, we use this
   relation to look up the relevant bb in the phi-bundle }%
pbundle-lookup : pbundle+ FTL -> bb-def-list FTL -> type.

pbundle-lookup/ctx-hit : pbundle-lookup (f-tl/z PB) FL
			  <- bb-bind PB FL.

pbundle-lookup/dig     : pbundle-lookup (f-tl/s PB) R
			  <- pbundle-lookup PB (bb-def-list/cons _ R).

bb-apply : bb-def (bb-tp/ TL T) -> reg-list TL -> insn T -> type.

bb-apply/body : bb-apply (bb-def/body E) reg-list/nil E.

bb-apply/phi  : bb-apply (bb-def/phi ([x] R x)) (reg-list/cons E EL) Q
		 <- bb-apply (R E) EL Q.



step-op : op T -> reg T -> type.

step-op/plus : step-op (op/plus (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-n N3)
		<- nat-plus N1 N2 N3.

step-op/cmp-lt : step-op (op/cmp-lt (reg/cst-n N1) (reg/cst-n N2)) (reg/cst-b B)
		  <- nat-lt N1 N2 B.

step : insn T -> insn T -> type.

step/let : step (insn/let T B) (B V)
	    <- step-op T V.

step/letrec-v : step (insn/letrec ([pb] Defs pb) ([pb] V)) V
		 <- value V.

step/letrec-s : step (insn/letrec ([pb] Defs pb) ([pb] Body pb))
                     (insn/letrec ([pb] Defs pb) ([pb] Body' pb))
		 <- ({pb} bb-bind pb (Defs pb) ->
		         step (Body pb) (Body' pb)).

step/brc-t : step (insn/brc (reg/cst-b (s _)) L RL _ _) (insn/br L RL).

step/brc-f : step (insn/brc (reg/cst-b z) _ _ L RL) (insn/br L RL).

step/do-s : step (insn/do T B) (insn/do T' B)
	   <- step T T'.

step/do-v : step (insn/do (insn/return R) B) (B R).

step/br : step (insn/br (f-hd PB) RL) E
	   <- pbundle-lookup PB (bb-def-list/cons BBDef _)
	   <- bb-apply BBDef RL E.

%{ Needed:
   call
}%


%{

**** Iterated step relations ****

}%

steps : insn T -> insn T -> type.

steps/0 : steps T T.

steps/s : steps T T'
	   <- step T T''
	   <- steps T'' T'.

steps-to : insn T -> insn T -> type.

steps-to/ : steps-to T V
	     <- steps T V
	     <- value V.



%{

step : tm T -> tm T -> type.


%% Binding construct for function-bundles
fb-bind : fbundle FTL -> fun-def-list FTL -> type.
%mode fb-bind +FB -FDef.

%{ To appease Twelf splitter }%
fb-bind0 : fb-bind fbundle0 fun-def-list/nil.

fbundle-lookup : fbundle+ FTL -> fun-def-list FTL -> type.

fbundle-lookup/ctx-hit : fbundle-lookup (f-tl/z FB) FL
			  <- fb-bind FB FL.

fbundle-lookup/dig : fbundle-lookup (f-tl/s FB) R
		       <- fbundle-lookup FB (fun-def-list/cons _ R).




fun-apply : fun-def (fun-tp/ TL T) -> reg-list TL -> tm T -> type.

fun-apply/body : fun-apply (fun-def/body E) reg-list/nil E.

fun-apply/parm : fun-apply (fun-def/parm ([x] R x)) (reg-list/cons E EL) Q
		  <- fun-apply (R E) EL Q.




step/plus : step (tm/plus (reg/cst-n N1) (reg/cst-n N2)) (tm/reg (reg/cst-n N3))
		    <- nat-plus N1 N2 N3.

step/let-s : step (tm/let T B) (tm/let T' B)
	      <- step T T'.

step/let-a : step (tm/let (tm/reg V) B) (B V)
	      <- value (tm/reg V).

step/if-f : step (tm/if (reg/cst-b z) T F) T.

step/if-t : step (tm/if (reg/cst-b (s _)) T F) F.



step/letrec-v : step (tm/letrec ([fb] Defs fb) ([fb] V)) V
		 <- value V.

step/letrec-s : step (tm/letrec ([fb] Defs fb) ([fb] Body fb))
		     (tm/letrec ([fb] Defs fb) ([fb] Body' fb))
		 <- ({fb} fb-bind fb (Defs fb) ->
		       step (Body fb) (Body' fb)).

step/call : step (tm/br (f-hd FB) EL) E
	     <- fbundle-lookup FB (fun-def-list/cons FDef _)
	     <- fun-apply FDef EL E.

}%
