%{

******** Type System ********

}%

%% Primitive types
tp : type. %name tp Tp.

tp/nat : tp.
tp/bool : tp.

%% Lists of primitive types
tp-list : type. %name tp-list TpL.

tp-list/nil : tp-list.
tp-list/cons : tp -> tp-list -> tp-list.

%% Basic-block types
bb-tp : type. %name bb-tp BBTp.
%% There is only way to introduce a function type.
bb-tp/ : tp-list -> tp -> bb-tp.

bb-tp-list : type. %name bb-tp-list BBTpL.
bb-tp-list/nil : bb-tp-list.
bb-tp-list/cons : bb-tp -> bb-tp-list -> bb-tp-list.

%{

******** Syntax ********

}%

%{

Registers is a family of either constants or variables. But as variables
are captured by HOAS, we do not need to specify them.

Expressions are either constants, additions or less-than comparisons
in this silly language.

}%

reg : tp -> type. %name reg R r.

reg/cst-n : nat -> reg tp/nat.
reg/cst-b : nat -> reg tp/bool.

%{

We will need lists of registers when one makes function calls and when one
jumps to other basic blocks. Hence, we define them here

}%

reg-list : tp-list -> type. %name reg-list RL.

reg-list/nil : reg-list tp-list/nil.
reg-list/cons : reg T -> reg-list TL -> reg-list (tp-list/cons T TL).

%{ Introduction of function bundles.

   Function names
   Function bundles

   TODO: DOCUMENT FOR GODS SAKE!
}%

fname : bb-tp -> type. %name fname Fn.
pbundle : bb-tp-list -> type.
pbundle+ : bb-tp-list -> type.

%{ This constant only exists to appease Twelfs splitter in the input coverage }%
pbundle0 : pbundle bb-tp-list/nil.

f-hd : pbundle+ (bb-tp-list/cons FT FTL) -> fname FT.
f-tl/z : pbundle FTL -> pbundle+ FTL.
f-tl/s : pbundle+ (bb-tp-list/cons FT FTL) -> pbundle+ FTL.



op : tp -> type.
%{ Instructions. Either assigning to a register, a return or a branch.
   These take care of control flow }%
insn : tp -> type.

op-list : tp-list -> type.

op-list/nil : op-list tp-list/nil.
op-list/cons : op T -> op-list TL -> op-list (tp-list/cons T TL).

%{ Syntactic term equality }%
op-eq : op T -> op T -> type.

op-eq/refl : op-eq T T.


fun-id : tp -> tp-list -> type.

fun-id/ : nat -> fun-id T TL.


bb-def : bb-tp -> type.

bb-def/body : insn T -> (bb-def (bb-tp/ tp-list/nil T)).
bb-def/phi : (reg T0 -> bb-def (bb-tp/ TL T)) -> bb-def (bb-tp/ (tp-list/cons T0 TL) T).

bb-def-list : bb-tp-list -> type.

bb-def-list/nil : bb-def-list bb-tp-list/nil.
bb-def-list/cons : bb-def FT -> bb-def-list FTL -> bb-def-list (bb-tp-list/cons FT FTL).

bb-list : bb-tp-list -> type.

bb-list/nil : bb-list bb-tp-list/nil.
bb-list/cons : bb-def FT -> bb-list FTL -> bb-list (bb-tp-list/cons FT FTL).


%{ Operations. These are simple operations returning a value to a register }%
%{ Primitive constants }%
op/reg : reg T -> op T.

%{ Operations on registers }%
op/plus   : reg tp/nat -> reg tp/nat -> op tp/nat.
op/cmp-lt : reg tp/nat -> reg tp/nat -> op tp/bool.
op/mone   : reg tp/nat -> reg tp/nat -> op tp/nat.

%{ Binding }%
insn/return : reg T -> insn T.

insn/br : fname (bb-tp/ TL T) -> reg-list TL -> insn T.
insn/brc : reg tp/bool -> fname (bb-tp/ TL T) -> reg-list TL
                     -> fname (bb-tp/ TL1 T) -> reg-list TL1 -> insn T.
insn/let : op T1 -> (reg T1 -> insn T) -> insn T.
insn/letrec : (pbundle FTL -> bb-def-list FTL)
               -> (pbundle FTL -> insn T) -> insn T.
insn/do : insn T' -> (reg T' -> insn T) -> insn T. %% Only internally used
%{
insn/call : fun-id T TL -> reg-list TL -> (reg T -> insn T) -> insn T.
}%

%{ **** Functions **** }%

fid : type.
fid/ : nat -> fid.


%% TODO: Should functions bear static information about their types?
fun-decl : type.

fun-decl/parm : (reg T -> fun-decl) -> fun-decl.
fun-decl/body : insn T -> fun-decl.


defs : type.

defs/z : defs.
defs/s : fid -> fun-decl -> defs -> defs.

pgm : type.
pgm/ : defs -> insn T -> pgm.


