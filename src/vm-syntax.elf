%{

******** Type System ********

}%

%% Primitive types
tp : type. %name tp Tp.

tp/nat : tp.
tp/bool : tp.

%% Lists of primitive types
tp-list : type. %name tp-list TpL.

tp-list/nil : tp-list.
tp-list/cons : tp -> tp-list -> tp-list.

%% Function types
fun-tp : type. %name fun-tp FTp.
%% There is only way to introduce a function type.
fun-tp/ : tp-list -> tp -> fun-tp.

fun-tp-list : type. %name fun-tp-list FTpL.
fun-tp-list/nil : fun-tp-list.
fun-tp-list/cons : fun-tp -> fun-tp-list -> fun-tp-list.

%{

******** Syntax ********

}%

%{

Registers is a family of either constants or variables. But as variables
are captured by HOAS, we do not need to specify them.

Expressions are either constants, additions or less-than comparisons
in this silly language.

}%

reg : tp -> type. %name reg R r.

reg/cst-n : nat -> reg tp/nat.
reg/cst-b : nat -> reg tp/bool.

%{

We will need lists of registers when one makes function calls and when one
jumps to other basic blocks. Hence, we define them here

}%

reg-list : tp-list -> type. %name reg-list RL.

reg-list/nil : reg-list tp-list/nil.
reg-list/cons : reg T -> reg-list TL -> reg-list (tp-list/cons T TL).

%{ Introduction of function bundles.

   Function names
   Function bundles

   TODO: DOCUMENT FOR GODS SAKE!
}%

fname : fun-tp -> type. %name fname Fn.
fbundle : fun-tp-list -> type.
fbundle+ : fun-tp-list -> type.

%{ This constant only exists to appease Twelfs splitter in the input coverage }%
fbundle0 : fbundle fun-tp-list/nil.

f-hd : fbundle+ (fun-tp-list/cons FT FTL) -> fname FT.
f-tl/z : fbundle FTL -> fbundle+ FTL.
f-tl/s : fbundle+ (fun-tp-list/cons FT FTL) -> fbundle+ FTL.



tm : tp -> type.
tm-list : tp-list -> type.

tm-list/nil : tm-list tp-list/nil.
tm-list/cons : tm T -> tm-list TL -> tm-list (tp-list/cons T TL).

%{ Syntactic term equality }%
tm-eq : tm T -> tm T -> type.

tm-eq/refl : tm-eq T T.



fun-def : fun-tp -> type.

fun-def/body : tm T -> (fun-def (fun-tp/ tp-list/nil T)).
fun-def/parm : (tm T0 -> fun-def (fun-tp/ TL T)) -> fun-def (fun-tp/ (tp-list/cons T0 TL) T).

fun-def-list : fun-tp-list -> type.

fun-def-list/nil : fun-def-list fun-tp-list/nil.
fun-def-list/cons : fun-def FT -> fun-def-list FTL -> fun-def-list (fun-tp-list/cons FT FTL).

fun-list : fun-tp-list -> type.

fun-list/nil : fun-list fun-tp-list/nil.
fun-list/cons : fun-def FT -> fun-list FTL -> fun-list (fun-tp-list/cons FT FTL).


%{ Primitive constants }%
tm/reg : reg T -> tm T.

%{ Operations on registers }%
tm/plus  : reg tp/nat -> reg tp/nat -> reg tp/nat.

%{ Binding }%
tm/letrec : (fbundle FTL -> fun-def-list FTL)
               -> (fbundle FTL -> tm T) -> tm T.
tm/let : tm T1 -> (reg T1 -> tm T) -> tm T.

%{ Control flow }%
%{ The if-construction should be killed. It is basically a derived form of brc }%
tm/if : reg tp/bool -> tm T -> tm T -> tm T.
tm/return : reg T -> tm T.
tm/br : fname (fun-tp/ TL T) -> reg-list TL -> tm T.
%{
tm/brc : reg tp/bool -> fname (fun-tp/ TL T) -> reg-list TL
                     -> fname (fun-tp/ TL1 T) -> reg-list TL1 -> tm T.
}%





