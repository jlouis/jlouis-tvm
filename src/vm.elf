%% Definition of a LLVM-inspired Virtual Machine language
%% Jesper Louis Andersen, 2009.

%{

GLOBAL TODO:

- Implement the conditional branch instruction.
- Define semantics of Basic Blocks
- Implement the altered code from Appel's paper.
  TEST
- Begin constructing a type system with nats (i32)
  and booleans (i1).

}%

%{

>>> TODO
This is a list of observations made while defining this part of the
language.

* It looks as if the LLVM IR defines expressions as

exp : tp -> type.

rather than

exp : type.

This is NICE. I hoped for being able to define expressions as
type-dependent. Now it looks as if it is possible. At least it has to
be tried. Preservation for free in expressions are always a nice thing
to have.
<<<

* The two main desirable properties for this language is that of
preservation and progress w.r.t. types.

}%





%%%%%{ Maps }%%%%%

%{

In this part of the file, we define some mappings so we can store
things in the context. We hope this will make the development easier
later on.

We need:

A mapping from labels into basic blocks.

>>> NOTE
Perhaps we need more, but this is a start.
<<<

}%

%{

>>> NOTE
Currently, labels just are. I have not yet given them enough thought
to wonder about them. Perhaps we can add them as a higher-order style
entry and then refer them by this construction, but I'll rather
postpone the decision until later for now
<<<

A 'bb' designates a basic block. We will define their contents later on.

}%

label : type.
bb : type.
bb-map : label -> bb -> type.




%{

The LLVM IR is a linear instruction set. Code in a function is split
into basic blocks. A Basic block is defined as:

label:
  %i1 = phi(...);
  ...
  %in = phi(...);

  insn_1;
  ...
  insn_n;

  return/br;

That is, a basic block, is a label, followed by
eventual phi-nodes, followed by instructions linearly until we reach
either a br or a function return. Then we either proceed along
another basic block or return from the function in which the basic
block is defined.

This representation is easy to map into a graph-representation [Appel-SSA],
but it is not an optimal representation for an inference rule system,
nor Twelf. We want to utilize the ideas in [Appel-SSA] to rewrite this
system into one which is amenable for definition in Twelf.

>>> GOAL
Our goal is to get a way to define the Example from [Appel] in our
small toy-language here and use it to structure a skeleton for further
work.
<<<

>>> TODO
We do not explain anything about phi-nodes yet. We ought to.
<<<

Suppose we only have assignment instructions of the form

%x = exp;

where 'exp' is either a constant, or of the form %x + %y for variables
x and y. For simplicity we will let the constants be natural numbers
for the moment.

}%






%%%%%{ Expression Syntax }%%%%%

%{

Registers is a family of either constants or variables. But as variables
are captured by HOAS, we do not need to specify them.

Expressions are either additions or less-than comparisons in this silly
language.

}%

reg : type. %name reg R.

reg/constant : nat -> reg.

exp : type. %name exp E.

exp/plus : reg -> reg -> exp.
exp/lt : reg -> reg -> exp.


%{

>>> NOTE
We stratify into 'reg' and 'exp' respectively to eliminate arbitrarily
nested expression trees. In the LLVM IR we only have primitive operations
or [constant expressions] which are expression trees that can be constant
folded. They are omitted for now, and possibly forever because they don't
provide anything interesting, in my humble opinion.

To me, they were added as a convenience so one can do e.g. address
calculations on a load word instruction.

<<<

}%

%{

We will need lists of registers when one makes function calls and when one
jumps to other basic blocks. Hence, we define them here

}%

reg-list : type.

reg-list/nil : reg-list.
reg-list/cons : reg -> reg-list -> reg-list.





%%%%%{ Expression Semantics }%%%%%

%{

I have decided on using small-step semantics rather than a big-step
semantics. This choice is made somewhat haphazardly on the gut
intuition that it will beneficial to have fine-grained control over
what happens.


}%

exp-step : exp -> reg -> type.

exp-step/plus : exp-step (exp/plus (reg/constant N1)
			           (reg/constant N2))
		     (reg/constant N3)
		 <- nat-plus N1 N2 N3.

exp-step/lt-true : exp-step (exp/lt (reg/constant N1) (reg/constant N2)) (reg/constant one)
		    <- nat-lt N1 N2 true.

exp-step/lt-false : exp-step (exp/lt (reg/constant N1) (reg/constant N2)) (reg/constant zero)
		     <- nat-lt N1 N2 false.


%{

Note how the step-rule only allows addition among constants. This
limitation is chosen to cope with the fact that we won't allow
arbitrarily nested expression trees.

}%







%%%%%{ Instruction syntax }%%%%%

%{

We have supposed assignment instructions are of the form

%x = exp

so a series of assignment instructions are of the form

%x1 = exp1;
%x2 = exp2;
...
%xn = expn;

Note that we use an SSA-form. This means that an assignment to x1 is
static. In other words, once x1 is assigned to in the first line, it
is impossible to reassign another value to x1. This effectively makes
x1 a constant in the following evaluation.

As an example, suppose we have the following code segment:

%x1 = 3;
%x2 = 7;
return %x1 + %x2;

This can be transformed into a functionally styled program as

let x1 = 3 in
  let x2 = 7 in
    return x1 + x2;

Which we can then transform to an equivalent program by using
lambda-abstractions for the let-body:

let 3 in
  (fn x1 => let 7 in
    (fn x2 => return x1 + x2))

The latter style is amenable to a HOAS Twelf encoding as follows. We will
define the basic operations of the language as being 'instruction's.

}%

instruction : type. %name instruction I.

instruction/let : exp -> (reg -> instruction) -> instruction.
instruction/return : reg -> instruction.
instruction/br : label -> reg-list -> instruction.

%abbrev let = instruction/let.
%abbrev return = instruction/return.
%abbrev br = instruction/br.



%%%%%{ Basic Block Syntax }%%%%%

%{

Basic blocks are defined by a label and then a possible list of
phi-nodes. These resembles the let-construction in instructions, but
we can handle them more easily by building them into basic-blocks.

>>> NOTE
This also enforces phi-nodes to be the first thing in basic blocks by
construction
<<<

We thus set out to define basic-block headers:

}%

bb-header : type.

bb-header/phi : (reg -> bb-header) -> bb-header.
bb-header/body : instruction -> bb-header.

%abbrev phi = bb-header/phi.
%abbrev body = bb-header/body.

%{

A basic block (bb) defines a label, identifying the basic block and
then it contains a bb-header. We have already introduced the bb type family.

}%

bb/def : label -> bb-header -> bb.


%{

Here is the notational idea. A set of LLVM instructions of the form

foo:
  %p1 = phi(..,..)
  %x1 = 3;
  %x2 = %p1;
  return %x1 + %x2;

is then translated into

(bb "foo" (phi [p1]
	     (body
		(let 3 in
		   [x1] let p1 in
		     [x2] return (plus [x1] [x2])))))

(We still need to take care of the "foo" part, but the idea is there)

}%



%{

We will need lists of basic blocks. Note that if we
have the code:

label1:
  ...
  <no jump or return here>
label2:
  ...

we can always fix it by an explicit jump just before label2. Thus, it
seems ok to define lists of basic blocks as a primitive for functions.

}%


bb-list : type.

bb-list/nil : bb-list.
bb-list/cons : label -> bb -> bb-list -> bb-list.




%%%%%{ Instruction Semantics }%%%%%

%{

Evaluation of Instructions utilizes beta-reduction. As soon as we know
the value of a definition, we replace it into all uses by
substitution.

Again, we use a simple stepping relation, small-step style.

Finally, the bb-apply relation is defined here so we can refer to it in
the step/br case, but we will handle it in the Basic Block Semantics section.

}%

bb-apply : reg-list -> bb-header -> instruction -> type.



instruction-step : instruction -> instruction -> type.

instruction-step/let : instruction-step (instruction/let E ([x] I x)) (I E')
			<- exp-step E E'.

instruction-step/return : instruction-step (instruction/return R) (instruction/return R).

instruction-step/br : instruction-step (instruction/br L EL) IS
		       <- bb-map L (bb/def _ BBH)
		       <- bb-apply EL BBH IS.







%%%%%{ Basic Block Semantics }%%%%%

%{

>>> TODO
Define BB evaluation. To do this, one must define a set of rules for
correctly handling the phi-node substitions. The definition ties in
with ways to tail-call (jump) to another basic block, so care must be
taken here to do it correctly.
<<<

}%

%{

The following applies a list of expressions to a basic-block header, effectively
executing the basic block by substituting the values into the block.

}%

bb-apply/nil : bb-apply reg-list/nil (bb-header/body I) I.

bb-apply/cons : bb-apply (reg-list/cons REG RL) (bb-header/phi ([x] PHI x)) I
		 <- bb-apply RL (PHI REG) I.



%%%%%{ Function Syntax }%%%%%


%{

The function body itself designates one basic block as the initial block by
its label. This is the block we run when asked.

}%

function-body : type.

function-body/def : label -> bb-list -> function-body.







%%%%%{ Function Semantics }%%%%%

%{

Currently, we use some very crippled function semantics. We just tell how a function
body should be executed. The plan is to wrap this knowledge later on.

First is the setup rules which allows us to set up before executing a function body. This
amount to shuffling basic blocks into the context so we can refer them later.

}%

function-body-init : label -> bb-list -> bb -> type.

function-body-init/nil : function-body-init L bb-list/nil BB
			  <- bb-map L BB.

function-body-init/cons : function-body-init L (bb-list/cons L BB REST) Q
			   <- (bb-map L BB -> function-body-init L REST Q).



